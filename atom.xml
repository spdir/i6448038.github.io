<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>RyuGou的博客</title>
  
  <subtitle>未来的不可知，是你前进的动力源</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-11-30T18:20:17.119Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Ryu Gou</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>图解redis五种数据结构底层实现(动图哦)</title>
    <link href="http://yoursite.com/2019/12/01/redis-data-struct/"/>
    <id>http://yoursite.com/2019/12/01/redis-data-struct/</id>
    <published>2019-11-30T18:20:40.000Z</published>
    <updated>2019-11-30T18:20:17.119Z</updated>
    
    <content type="html"><![CDATA[<p>redis有五种基本数据结构：字符串、hash、set、zset、list。但是你知道构成这五种结构的底层数据结构是怎样的吗？<br>今天我们来花费五分钟的时间了解一下。<br>(目前redis版本为3.0.6)</p><h1 id="动态字符串SDS"><a href="#动态字符串SDS" class="headerlink" title="动态字符串SDS"></a>动态字符串SDS</h1><p>SDS是”simple dynamic string”的缩写。<br>redis中所有场景中出现的字符串，基本都是由SDS来实现的</p><ul><li>所有非数字的key。例如<code>set msg &quot;hello world&quot;</code> 中的key msg.</li><li>字符串数据类型的值。例如`` set msg “hello world”中的msg的值”hello wolrd”</li><li>非字符串数据类型中的“字符串值”。例如<code>RPUSH fruits &quot;apple&quot; &quot;banana&quot; &quot;cherry&quot;</code>中的”apple” “banana” “cherry”</li></ul><h3 id="SDS长这样："><a href="#SDS长这样：" class="headerlink" title="SDS长这样："></a>SDS长这样：</h3><p><img src="/img/redis-data-struct/sds.png" alt></p><p>free:还剩多少空间<br>len:字符串长度<br>buf:存放的字符数组</p><h3 id="空间预分配"><a href="#空间预分配" class="headerlink" title="空间预分配"></a>空间预分配</h3><p>为减少修改字符串带来的内存重分配次数，sds采用了“一次管够”的策略：</p><ul><li>若修改之后sds长度小于1MB,则多分配现有len长度的空间</li><li>若修改之后sds长度大于等于1MB，则扩充除了满足修改之后的长度外，额外多1MB空间</li></ul><p><img src="/img/redis-data-struct/sds.gif" alt></p><h3 id="惰性空间释放"><a href="#惰性空间释放" class="headerlink" title="惰性空间释放"></a>惰性空间释放</h3><p>为避免缩短字符串时候的内存重分配操作，sds在数据减少时，并不立刻释放空间。</p><p><img src="/img/redis-data-struct/sds_free.gif" alt></p><h1 id="int"><a href="#int" class="headerlink" title="int"></a>int</h1><p>就是redis中存放的各种数字<br>包括一下这种，故意加引号“”的</p><p><img src="/img/redis-data-struct/int.png" alt></p><h1 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h1><p>长这样：</p><p><img src="/img/redis-data-struct/linklist.png" alt></p><p>分两部分，一部分是“统筹部分”：橘黄色，一部分是“具体实施方“：蓝色。</p><p>主体”统筹部分“：</p><ul><li><code>head</code>指向具体双向链表的头</li><li><code>tail</code>指向具体双向链表的尾</li><li><code>len</code>双向链表的长度</li></ul><p>具体”实施方”：一目了然的双向链表结构，有前驱<code>pre</code>有后继<code>next</code></p><p>由<code>list</code>和<code>listNode</code>两个数据结构构成。</p><h1 id="ziplist"><a href="#ziplist" class="headerlink" title="ziplist"></a>ziplist</h1><p>压缩列表。<br>redis的列表键和哈希键的底层实现之一。此数据结构是为了节约内存而开发的。和各种语言的数组类似，它是由连续的内存块组成的，这样一来，由于内存是连续的，就减少了很多内存碎片和指针的内存占用，进而节约了内存。</p><p><img src="/img/redis-data-struct/ziplist_total.png" alt></p><p>然后文中的<code>entry</code>的结构是这样的：</p><p><img src="/img/redis-data-struct/ziplist_entry.png" alt></p><h3 id="元素的遍历"><a href="#元素的遍历" class="headerlink" title="元素的遍历"></a>元素的遍历</h3><p>先找到列表尾部元素：</p><p><img src="/img/redis-data-struct/ziplist_bianli1.gif" alt></p><p>然后再根据ziplist节点元素中的<code>previous_entry_length</code>属性，来逐个遍历:</p><p><img src="/img/redis-data-struct/ziplist_bianli2.gif" alt></p><h3 id="连锁更新"><a href="#连锁更新" class="headerlink" title="连锁更新"></a>连锁更新</h3><p>再次看看<code>entry</code>元素的结构，有一个<code>previous_entry_length</code>字段，他的长度要么都是1个字节，要么都是5个字节：</p><ul><li>前一节点的长度小于254字节，则<code>previous_entry_length</code>长度为1字节</li><li>前一节点的长度小于254字节，则<code>previous_entry_length</code>长度为5字节</li></ul><p>假设现在存在一组压缩列表，长度都在250字节至253字节之间，突然新增一新节点<code>new</code>，<br>长度大于等于254字节，会出现：</p><p><img src="/img/redis-data-struct/ziplist_refresh.gif" alt></p><p>程序需要不断的对压缩列表进行空间重分配工作，直到结束。</p><p>除了增加操作，删除操作也有可能带来“连锁更新”。<br>请看下图，ziplist中所有entry节点的长度都在250字节至253字节之间，big节点长度大于254字节，small节点小于254字节。</p><p><img src="/img/redis-data-struct/ziplist_sub_refresh.gif" alt></p><h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><p>哈希表略微有点复杂。哈希表的制作方法一般有两种，一种是：<code>开放寻址法</code>，一种是<code>拉链法</code>。redis的哈希表的制作使用的是<code>拉链法</code>。</p><p>整体结构如下图：</p><p><img src="/img/redis-data-struct/hash1.png" alt></p><p>也是分为两部分：左边橘黄色部分和右边蓝色部分，同样，也是”统筹“和”实施“的关系。<br>具体哈希表的实现，都是在蓝色部分实现的。<br>先来看看蓝色部分：</p><p><img src="/img/redis-data-struct/hash2.png" alt></p><p>这也分为左右两边“统筹”和“实施”的两部分。</p><p>右边部分很容易理解：就是通常拉链表实现的哈希表的样式；数组就是bucket，一般不同的key首先会定位到不同的bucket，若key重复，就用链表把冲突的key串起来。</p><h3 id="新建key的过程："><a href="#新建key的过程：" class="headerlink" title="新建key的过程："></a>新建key的过程：</h3><p><img src="/img/redis-data-struct/hash_key.gif" alt></p><h3 id="假如重复了"><a href="#假如重复了" class="headerlink" title="假如重复了:"></a>假如重复了:</h3><p><img src="/img/redis-data-struct/hash_key_dup.gif" alt></p><h2 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h2><p>再来看看哈希表总体图中左边橘黄色的“统筹”部分，其中有两个关键的属性：<code>ht</code>和<code>rehashidx</code>。<br><code>ht</code>是一个数组，有且只有俩元素ht[0]和ht[1];其中，ht[0]存放的是redis中使用的哈希表，而ht[1]和rehashidx和哈希表的<code>rehash</code>有关。</p><p><code>rehash</code>指的是重新计算键的哈希值和索引值，然后将键值对重排的过程。</p><p><code>加载因子（load factor） = ht[0].used / ht[0].size</code>。</p><h3 id="扩容和收缩标准"><a href="#扩容和收缩标准" class="headerlink" title="扩容和收缩标准"></a>扩容和收缩标准</h3><p>扩容：</p><ul><li>没有执行BGSAVE和BGREWRITEAOF指令的情况下，哈希表的<code>加载因子</code>大于等于1。</li><li>正在执行BGSAVE和BGREWRITEAOF指令的情况下，哈希表的<code>加载因子</code>大于等于5。</li></ul><p>收缩:</p><ul><li><code>加载因子</code>小于0.1时，程序自动开始对哈希表进行收缩操作。</li></ul><h3 id="扩容和收缩的数量"><a href="#扩容和收缩的数量" class="headerlink" title="扩容和收缩的数量"></a>扩容和收缩的数量</h3><p>扩容：</p><ul><li>第一个大于等于<code>ht[0].used * 2</code>的<code>2^n</code>(2的n次方幂)。</li></ul><p>收缩：</p><ul><li>第一个大于等于<code>ht[0].used</code>的<code>2^n</code>(2的n次方幂)。</li></ul><p><strong>(以下部分属于细节分析，可以跳过直接看扩容步骤)</strong><br>对于收缩，我当时陷入了疑虑：收缩标准是<code>加载因子</code>小于0.1的时候，也就是说假如哈希表中有4个元素的话，哈希表的长度只要大于40，就会进行收缩，假如有一个长度大于40，但是存在的元素为4即(<code>ht[0].used</code>为4)的哈希表，进行收缩，那收缩后的值为多少？</p><p>我想了一下：按照前文所讲的内容，应该是4。<br>但是，假如是4，存在和收缩后的长度相等，是不是又该扩容？<br>翻开源码看看：</p><p>收缩具体函数:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dictResize(dict *d)     <span class="comment">//缩小字典d</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> minimal;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果dict_can_resize被设置成0，表示不能进行rehash，或正在进行rehash，返回出错标志DICT_ERR</span></span><br><span class="line">    <span class="keyword">if</span> (!dict_can_resize || dictIsRehashing(d)) <span class="keyword">return</span> DICT_ERR;</span><br><span class="line"></span><br><span class="line">    minimal = d-&gt;ht[<span class="number">0</span>].used;            <span class="comment">//获得已经有的节点数量作为最小限度minimal</span></span><br><span class="line">    <span class="keyword">if</span> (minimal &lt; DICT_HT_INITIAL_SIZE)<span class="comment">//但是minimal不能小于最低值DICT_HT_INITIAL_SIZE（4）</span></span><br><span class="line">        minimal = DICT_HT_INITIAL_SIZE;</span><br><span class="line">    <span class="keyword">return</span> dictExpand(d, minimal);      <span class="comment">//用minimal调整字典d的大小</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dictExpand(dict *d, unsigned long size)     <span class="comment">//根据size调整或创建字典d的哈希表</span></span><br><span class="line">&#123;</span><br><span class="line">    dictht n; </span><br><span class="line">    unsigned long realsize = _dictNextPower(size);  <span class="comment">//获得一个最接近2^n的realsize</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d) || d-&gt;ht[<span class="number">0</span>].used &gt; size) <span class="comment">//正在rehash或size不够大返回出错标志</span></span><br><span class="line">        <span class="keyword">return</span> DICT_ERR;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (realsize == d-&gt;ht[<span class="number">0</span>].size) <span class="keyword">return</span> DICT_ERR; <span class="comment">//如果新的realsize和原本的size一样则返回出错标志</span></span><br><span class="line">    <span class="comment">/* Allocate the new hash table and initialize all pointers to NULL */</span></span><br><span class="line">    <span class="comment">//初始化新的哈希表的成员</span></span><br><span class="line">    n.size = realsize;</span><br><span class="line">    n.sizemask = realsize<span class="number">-1</span>;</span><br><span class="line">    n.table = zcalloc(realsize*sizeof(dictEntry*));</span><br><span class="line">    n.used = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Is this the first initialization? If so it's not really a rehashing</span></span><br><span class="line"><span class="comment">     * we just set the first hash table so that it can accept keys. */</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].table == NULL) &#123;   <span class="comment">//如果ht[0]哈希表为空，则将新的哈希表n设置为ht[0]</span></span><br><span class="line">        d-&gt;ht[<span class="number">0</span>] = n;</span><br><span class="line">        <span class="keyword">return</span> DICT_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    d-&gt;ht[<span class="number">1</span>] = n;           <span class="comment">//如果ht[0]非空，则需要rehash</span></span><br><span class="line">    d-&gt;rehashidx = <span class="number">0</span>;       <span class="comment">//设置rehash标志位为0，开始渐进式rehash（incremental rehashing）</span></span><br><span class="line">    <span class="keyword">return</span> DICT_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static unsigned long _dictNextPower(unsigned long size)</span><br><span class="line">&#123;</span><br><span class="line">    unsigned long i = DICT_HT_INITIAL_SIZE; <span class="comment">//DICT_HT_INITIAL_SIZE 为 4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &gt;= LONG_MAX) <span class="keyword">return</span> LONG_MAX + <span class="number">1</span>LU;</span><br><span class="line">    while(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        i *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由代码我们可以看到，假如收缩后长度为4，不仅不会收缩，甚至还会报错。(😝)</p><p>我们回过头来再看看设定：题目可能成立吗？<br>哈希表的扩容都是2倍增长的，最小是4，<br>4 ===》 8 ====》 16 =====》 32 ======》 64 ====》 128</p><p>也就是说：不存在长度为 40多的情况，只能是64。但是如果是64的话，64 X 0.1（收缩界限）= 6.4 ，也就是说在减少到6的时候，哈希表就会收缩，会缩小到多少呢？是8。此时，再继续减少到4，也不会再收缩了。所以，根本不存在一个长度大于40，但是存在的元素为4的哈希表的。</p><h3 id="扩容步骤"><a href="#扩容步骤" class="headerlink" title="扩容步骤"></a>扩容步骤</h3><p><img src="/img/redis-data-struct/hash_refresh.gif" alt></p><h3 id="收缩步骤"><a href="#收缩步骤" class="headerlink" title="收缩步骤"></a>收缩步骤</h3><p><img src="/img/redis-data-struct/hash_refresh_release.gif" alt></p><h3 id="渐进式refresh"><a href="#渐进式refresh" class="headerlink" title="渐进式refresh"></a>渐进式refresh</h3><p>在”扩容步骤”和”收缩步骤” 两幅动图中每幅图的第四步骤“将ht[0]中的数据利用哈希函数重新计算，rehash到ht[1]”，并不是一步完成的，而是分成N多步，循序渐进的完成的。<br>因为hash中有可能存放几千万甚至上亿个key，毕竟Redis中每个hash中可以存<code>2^32 - 1</code> 键值对（40多亿），假如一次性将这些键值rehash的话，可能会导致服务器在一段时间内停止服务，毕竟哈希函数就得计算一阵子呢((#^.^#))。</p><p>哈希表的refresh是分多次、渐进式进行的。</p><p>渐进式refresh和下图中左边橘黄色的“统筹”部分中的<code>rehashidx</code>密切相关：</p><ul><li>rehashidx 的数值就是现在rehash的元素位置</li><li>rehashidx 等于 -1 的时候说明没有在进行refresh</li></ul><p><img src="/img/redis-data-struct/rehashidx.png" alt></p><p>甚至在进行期间，每次对哈希表的增删改查操作，除了正常执行之外，还会顺带将ht[0]哈希表相关键值对rehash到ht[1]。</p><p>以扩容步骤为例：</p><p><img src="/img/redis-data-struct/hash_refresh_slow.gif" alt></p><h1 id="intset"><a href="#intset" class="headerlink" title="intset"></a>intset</h1><p>整数集合是集合键的底层实现方式之一。<br><img src="/img/redis-data-struct/inset.png" alt></p><h1 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h1><p>跳表这种数据结构长这样：<br><img src="/img/redis-data-struct/skiplist.png" alt></p><p>redis中把跳表抽象成如下所示：</p><p><img src="/img/redis-data-struct/skiplist1.png" alt></p><p>看这个图，左边“统筹”，右边实现。<br>统筹部分有以下几点说明：</p><ul><li>header: 跳表表头</li><li>tail:跳表表尾</li><li>level:层数最大的那个节点的层数</li><li>length：跳表的长度</li></ul><p>实现部分有以下几点说明：</p><ul><li>表头：是链表的哨兵节点，不记录主体数据。</li><li>是个双向链表</li><li>分值是有顺序的</li><li>o1、o2、o3是节点所保存的成员，是一个指针，可以指向一个SDS值。</li><li>层级高度最高是32。没每次创建一个新的节点的时候，程序都会随机生成一个介于1和32之间的值作为level数组的大小，这个大小就是“高度”</li></ul><h1 id="redis五种数据结构的实现"><a href="#redis五种数据结构的实现" class="headerlink" title="redis五种数据结构的实现"></a>redis五种数据结构的实现</h1><h3 id="redis对象"><a href="#redis对象" class="headerlink" title="redis对象"></a>redis对象</h3><p>redis中并没有直接使用以上所说的各种数据结构来实现键值数据库，而是基于一种对象，对象底层再间接的引用上文所说的具体的数据结构。</p><p>结构如下图：</p><p><img src="/img/redis-data-struct/object_ptr.png" alt></p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p><img src="/img/redis-data-struct/object_string.png" alt></p><p>其中：embstr和raw都是由SDS动态字符串构成的。唯一区别是：raw是分配内存的时候，redisobject和 sds 各分配一块内存，而embstr是redisobject和raw在一块儿内存中。</p><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p><img src="/img/redis-data-struct/object_list.png" alt></p><h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><p><img src="/img/redis-data-struct/object_hash.png" alt></p><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p><img src="/img/redis-data-struct/object_set.png" alt></p><h3 id="zset"><a href="#zset" class="headerlink" title="zset"></a>zset</h3><p><img src="/img/redis-data-struct/object_zset.png" alt></p><h2 id="更多精彩内容，请关注我的微信公众号-互联网技术窝-或者加微信共同探讨交流："><a href="#更多精彩内容，请关注我的微信公众号-互联网技术窝-或者加微信共同探讨交流：" class="headerlink" title="更多精彩内容，请关注我的微信公众号 互联网技术窝  或者加微信共同探讨交流："></a>更多精彩内容，请关注我的微信公众号 <code>互联网技术窝</code>  或者加微信共同探讨交流：</h2><p>   <img src="https://i6448038.github.io/img/weichat/qrcode.jpg" alt></p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li><a href="https://throwsnew.com/2017/09/12/%E4%B8%BA%E4%BB%80%E4%B9%88Redis%E4%BD%BF%E7%94%A8ziplist%E8%83%BD%E8%8A%82%E7%9C%81%E5%86%85%E5%AD%98/" target="_blank" rel="noopener">https://throwsnew.com/2017/09/12/%E4%B8%BA%E4%BB%80%E4%B9%88Redis%E4%BD%BF%E7%94%A8ziplist%E8%83%BD%E8%8A%82%E7%9C%81%E5%86%85%E5%AD%98/</a></li><li>《redis设计与实现》</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;redis有五种基本数据结构：字符串、hash、set、zset、list。但是你知道构成这五种结构的底层数据结构是怎样的吗？&lt;br&gt;今天我们来花费五分钟的时间了解一下。&lt;br&gt;(目前redis版本为3.0.6)&lt;/p&gt;
&lt;h1 id=&quot;动态字符串SDS&quot;&gt;&lt;a href=
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>动图了解I/O多路复用</title>
    <link href="http://yoursite.com/2019/11/10/io-multi/"/>
    <id>http://yoursite.com/2019/11/10/io-multi/</id>
    <published>2019-11-10T11:18:08.000Z</published>
    <updated>2019-11-10T16:43:52.187Z</updated>
    
    <content type="html"><![CDATA[<p>啥叫I/O多路复用？<br>epoll又是个什么东西？<br>你或许看过很多文章，但是还是感觉云里雾里的，今天，我们抛开文字，释放动图，或许你就理解了。</p><h2 id="I-O多路复用"><a href="#I-O多路复用" class="headerlink" title="I/O多路复用"></a>I/O多路复用</h2><p>通常的一次的请求结果如下图所示：</p><p><img src="/img/io/normal.gif" alt></p><p>但是，服务器往往不会只处理一次请求，往往是多个请求，这一个请求，这时候每来一个请求，就会生成一个进程或线程。</p><p><img src="/img/io/normal_1.png" alt></p><p>在这些请求线程或者进程中，大部分都处于等待阶段，只有少部分是接收数据。这样一来，非常耗费资源，而且这些线程或者进程的管理，也是个事儿。</p><p><img src="/img/io/normal_2.png" alt></p><p>于是，有人想到一个办法：我们只用一个线程或者进程来和系统内核打交道，并想办法把每个应用的I/O流状态记录下来，一有响应变及时返回给相应的应用。</p><p><img src="/img/io/io_multi.png" alt></p><p>或者下图：</p><p><img src="/img/io/io_multi.jpeg" alt></p><h2 id="select、poll、epoll"><a href="#select、poll、epoll" class="headerlink" title="select、poll、epoll"></a>select、poll、epoll</h2><p>select, poll, epoll 都是I/O多路复用的具体实现，他们出现是有先后顺序的。</p><p>select是第一个实现 (1983 左右在BSD里面实现的)。</p><p>select 被实现后，发现诸多问题，然后1997年实现了poll，对select进行了改进，select和poll是很类似的。</p><p>再后来，2002做出重大改进实现了epoll。</p><p>epoll和 select/poll 有着很大的不同：</p><p>例如：select/poll的处理流程如下：</p><p><img src="/img/io/select.gif" alt></p><p>而epoll的处理流程如下：</p><p><img src="/img/io/epoll.gif" alt></p><p>这样，就无需遍历成千上万个消息列表了，直接可以定位哪个socket有数据。</p><p>那么，这是如何实现的呢？</p><p>早期的时候 epoll的实现是一个哈希表，但是后来由于占用空间比较大，改为了红黑树和链表。</p><p><img src="/img/io/epoll_rbtree.png" alt></p><p>其中链表中全部为活跃的链接，红黑树中放的是所有事件。两部分各司其职。<br>这样一来，当收到内核的数据时，只需遍历链表中的数据就行了，而注册read事件或者write事件的时候，向红黑树中记录。</p><p>结果导致： </p><ul><li>创建\修改\删除消息效率非常高：O(logN)。</li><li>获取活跃链接也非常快，因为在一个时间内，大部分是不活跃的链接，活跃的链接是少数，只需要遍历少数活跃的链接就好了</li></ul><h2 id="更多精彩内容，请关注我的微信公众号-互联网技术窝-或者加微信共同探讨交流："><a href="#更多精彩内容，请关注我的微信公众号-互联网技术窝-或者加微信共同探讨交流：" class="headerlink" title="更多精彩内容，请关注我的微信公众号 互联网技术窝  或者加微信共同探讨交流："></a>更多精彩内容，请关注我的微信公众号 <code>互联网技术窝</code>  或者加微信共同探讨交流：</h2><p>   <img src="https://i6448038.github.io/img/weichat/qrcode.jpg" alt></p><p>参考文献：</p><ul><li><a href="https://blog.csdn.net/qq_28098067/article/details/80537564" target="_blank" rel="noopener">https://blog.csdn.net/qq_28098067/article/details/80537564</a></li><li><a href="https://www.jianshu.com/p/397449cadc9a" target="_blank" rel="noopener">https://www.jianshu.com/p/397449cadc9a</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;啥叫I/O多路复用？&lt;br&gt;epoll又是个什么东西？&lt;br&gt;你或许看过很多文章，但是还是感觉云里雾里的，今天，我们抛开文字，释放动图，或许你就理解了。&lt;/p&gt;
&lt;h2 id=&quot;I-O多路复用&quot;&gt;&lt;a href=&quot;#I-O多路复用&quot; class=&quot;headerlink&quot; t
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>图解各路分布式ID生成算法</title>
    <link href="http://yoursite.com/2019/09/28/snowflake/"/>
    <id>http://yoursite.com/2019/09/28/snowflake/</id>
    <published>2019-09-28T10:40:30.000Z</published>
    <updated>2019-11-30T18:19:33.568Z</updated>
    
    <content type="html"><![CDATA[<p>在分布式系统中，通常会用到分布式ID来标注数据的唯一性，而分布式ID的生成方式又多种多样，今天我们就来讨论一下主流的分布式ID生成策略。</p><h2 id="分布式ID基本需求"><a href="#分布式ID基本需求" class="headerlink" title="分布式ID基本需求"></a>分布式ID基本需求</h2><ul><li>全局唯一</li><li>趋势递增</li><li>信息安全</li></ul><h3 id="全局唯一"><a href="#全局唯一" class="headerlink" title="全局唯一"></a>全局唯一</h3><p>这是基本要求，不必解释</p><h3 id="趋势递增"><a href="#趋势递增" class="headerlink" title="趋势递增"></a>趋势递增</h3><p>为什么要趋势递增呢？<br>第一，由于我们的分布式ID，是用来标识数据唯一性的，所以多数时候会被定义为主键或者唯一索引。<br>第二，并且绝大多数互联网公司使用的数据库是：MySQL，存储引擎为innoDB。<br>对于<code>B + Tree</code>这个数据结构来讲，数据以自增顺序来写入的话，b+tree的结构不会时常被打乱重塑，存取效率是最高的。</p><h3 id="信息安全"><a href="#信息安全" class="headerlink" title="信息安全"></a>信息安全</h3><p>由于数据是递增的，所以，恶意用户的可以根据当前ID推测出下一个，非常危险，所以，我们的分布式ID尽量做到不易被破解。</p><h2 id="数据库主键自增-Flicker"><a href="#数据库主键自增-Flicker" class="headerlink" title="数据库主键自增(Flicker)"></a>数据库主键自增(Flicker)</h2><p>基于数据库主键自增的方案，名为<code>Flicker</code>。<br>主要是利用MySQL的自增主键来实现分布式ID。</p><p>以下为<code>Flicker</code>实现分布式ID的主流做法：</p><h3 id="1、需要单独建立一个数据库实例：flicker"><a href="#1、需要单独建立一个数据库实例：flicker" class="headerlink" title="1、需要单独建立一个数据库实例：flicker"></a>1、需要单独建立一个数据库实例：flicker</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create database `flicker`;</span><br></pre></td></tr></table></figure><h3 id="2、创建一张表：sequence-id"><a href="#2、创建一张表：sequence-id" class="headerlink" title="2、创建一张表：sequence_id"></a>2、创建一张表：sequence_id</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create table sequence_id(</span><br><span class="line">    id bigint(20) unsigned NOT NULL auto_increment, </span><br><span class="line">    stub char(10) NOT NULL default &apos;&apos;,</span><br><span class="line">    PRIMARY KEY (id),</span><br><span class="line">    UNIQUE KEY stub (stub)</span><br><span class="line">) ENGINE=MyISAM;</span><br></pre></td></tr></table></figure><p>为什么用<code>MyISAM</code>？不用<code>InnoDB</code>？个人推测原因是：<code>flicker</code>算法出来的时候，MySQL的默认引擎还依旧是<code>MyISAM</code>而不是<code>InnoDB</code>，作者只是想用默认引擎而已，并无其他原因。</p><ul><li>stub: 票根，对应需要生成 Id 的业务方编码，可以是项目名、表名甚至是服务器 IP 地址。</li><li>stub 要设置为唯一索引</li></ul><h3 id="3、使用以下SQL来获取ID"><a href="#3、使用以下SQL来获取ID" class="headerlink" title="3、使用以下SQL来获取ID"></a>3、使用以下SQL来获取ID</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">REPLACE INTO ticket_center (stub) VALUES (&apos;test&apos;);  </span><br><span class="line">SELECT LAST_INSERT_ID();</span><br></pre></td></tr></table></figure><p><code>Replace into</code> 先尝试插入数据到表中，如果发现表中已经有此行数据（根据主键或者唯一索引判断）则先删除此行数据，然后插入新的数据， 否则直接插入新数据。<br>一般<code>stub</code>为特殊的相同的值。</p><p>这样，一个分布式ID系统算是可以搭建运行了。但是，有人要问：“这是一个单实例、单点的系统，万一挂了，岂不是影响所有关联的业务方？”</p><h3 id="改进升华"><a href="#改进升华" class="headerlink" title="改进升华"></a>改进升华</h3><p>是的。确实如此，因此又有人说：“可以利用MySQL主从模式，主库挂了，使用从库。”<br>这只能算是一种比较low的策略，因为如果主库挂了，从库没来得及同步，就会生成重复的ID。<br>有没有更好的方法呢？<br>我们可以使用“双主模式“，也就是有两个MySQL实例，这两个都能生成ID。<br>如图所示，我们原来的模式：<br><img src="/img/snowflake/mysql1.png" alt></p><p>双主模式是该怎么样呢？如何保持唯一性？<br>我们可以让一台实例生成奇数ID，另一台生成偶数ID。</p><p>奇数那一台：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set @@auto_increment_offset = 1;     -- 起始值</span><br><span class="line">set @@auto_increment_increment = 2;  -- 步长</span><br></pre></td></tr></table></figure><p>偶数那一台：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set @@auto_increment_offset = 2;     -- 起始值</span><br><span class="line">set @@auto_increment_increment = 2;  -- 步长</span><br></pre></td></tr></table></figure><p>当两台都OK的时候，随机取其中的一台生成ID；若其中一台挂了，则取另外一台生成ID。<br>如图所示：<br><img src="/img/snowflake/mysql2.png" alt></p><p>细心会发现，N个节点，只要起始值为1，2，…N，然后步长为N，就会生成各不相同的ID。(PS:后文有推导公式)</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>优点：</p><ul><li>简单。充分利用了数据库自增 ID 机制，生成的 ID 有序递增。</li><li>ID递增</li></ul><p>缺点：</p><ul><li>并发量不大。</li><li>水平扩展困难，系统定义好了起始值、步长和机器台数，跑起来之后，添加额外的机器困难。</li><li>安全系数低</li></ul><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>Redis为单线程的，所以操作为原子操作，利用<code>incrby</code>命令可以生成唯一的递增ID。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><img src="/img/snowflake/redis1.png" alt></p><p>单机单点，吞吐不够，加集群</p><p><img src="/img/snowflake/redis2.png" alt></p><p>假设N个节点，则步长为N，节点起始值为1，2，…… N。则三个节点生成的ID一定不同！<br>想想为什么？<br>以上信息条件可以转化为数学推理：<br><code>1 + x * N = 2 + y * N 且 x、y、N都为整成数且N不为1，试问等式存不存在？</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br><span class="line">假设存在在起始值是1的节点上叠加x次之后等于起始值为2、叠加y次的值，</span><br><span class="line">既 “1 + x * N = 2 + y * N” 等式成立</span><br><span class="line">则：</span><br><span class="line">x * N = 1 + y * N</span><br><span class="line">x * N - y * N = 1</span><br><span class="line">(x - y) * N = 1</span><br><span class="line">(x - y) = 1 / N</span><br><span class="line"></span><br><span class="line">又因为 x、y都为整成数；</span><br><span class="line">所以x - y 必为整成数；</span><br><span class="line">又因为只有N等于1的时候，1/N才为整成数；</span><br><span class="line">与条件N为1不符合，所以不存在。</span><br></pre></td></tr></table></figure><p>同理可证<code>1 + x * N = 3 + y * N</code>和<code>2 + x * N = 3 + y * N</code>也是如此。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>性能显然高于基于数据库的<code>Flicker</code>方案</li><li>ID递增</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>水平扩展困难</li><li>Redis集群宕机可能会产生重复的id</li><li>易破解</li></ul><h2 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a>UUID</h2><p>想必这个大家都熟悉。<br><code>UUID</code>是通用唯一识别码（Universally Unique Identifier）的缩写，是一种软件建构的标准，亦为开放软件基金会组织在分布式计算环境领域的一部分。</p><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p><img src="/img/snowflake/uuid1.png" alt></p><p>UUID是由一组32位数的16进制数字所构成，是故UUID理论上的总数为16^32 = 2^128，约等于3.4 x 10^38。也就是说若每纳秒产生1兆个UUID，要花100亿年才会将所有UUID用完。</p><p><code>UUID</code>是利用同一时空中的所有机器都是唯一的这一规则来确保唯一性的。</p><p><img src="/img/snowflake/uuid3.png" alt></p><p>具体外形为：<br><img src="/img/snowflake/uuid2.png" alt></p><p>通常由以下几部分组成：</p><ul><li>系统时间</li><li>时钟序列</li><li>全局唯一的IEEE机器识别，如网卡MAC、机器SN等</li></ul><p>生成方式多种多样，业界公认的是五种，分别是uuid1,uuid2,uuid3,uuid4,uuid5。<br>目前使用最广泛的UUID是微软的<code>GUID</code>。</p><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul><li>本地生成，性能极佳。无网络消耗</li><li>全局唯一</li></ul><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul><li>存储麻烦。16字节128位，通常以36长度的字符串表示，很多场景不适用</li><li>通常是字符串，非自增，无序，不利于做主键。每次插入都会对B+tree结构进行修改</li><li>破解相对困难，但是也不安全。参考”梅丽莎病毒事件，病毒作者制作的UUID包含Mac地址，被警方破解后，直接定位，抓捕归案😝”</li></ul><h2 id="snowflake"><a href="#snowflake" class="headerlink" title="snowflake"></a>snowflake</h2><p>snowflake即雪花算法，Twitter发明的。</p><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>外形长这样：<br><img src="/img/snowflake/snowflake.jpeg" alt></p><ul><li><code>1位</code>不用。二进制中最高位为1的都是负数，但是我们生成的id一般都使用整数，所以这个最高位固定是0。</li><li><code>41位</code>，用来记录毫秒的时间戳。41位可以表示的数值范围是：0 至 2^{41}-1，减1是因为可表示的数值范围是从0开始算的，而不是1，转化为年则是<code>2^{41}-1) / (1000 * 60 * 60 * 24 * 365) = 69</code>年。</li><li><code>10位</code>，用来记录工作机器id。最多可以部署在2^{10} = 1024个节点，我们可以根据具体的业务来定制具体分配的机器数量和每台机器1毫秒产生的id序号number数。例如可以把10bit分5bit给IDC，分5bit给工作机器。这样就可以表示32个IDC，每个IDC下可以有32台机器，可以将内容配置在配置文件中，服务去获取。</li><li><code>12位</code>。用来表示单台机器每毫秒生成的id序号，12位bit可以表示的最大正整数为2^12 - 1 = 4096，若超过4096，则重新从0开始。即，每台机器1毫秒内最多产生4096个ID，足够用了。</li></ul><p>最后将上述4段bit通过位运算拼接起来组成64位bit.<br>由于是64位bit,所以完全可以用数字来表示ID。</p><p>基本是根据：</p><p><img src="/img/snowflake/snowflake1.png" alt></p><h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><ul><li>ID为数字且时间位在高位，整个ID都是趋势递增的。</li><li>不依赖任何第三方库，完全可以自己写，且性能非常高。</li><li>可根据业务定制分配bit位，非常灵活。得益于<code>10位</code>机器IDbit位。</li><li>不太容易破解</li></ul><h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><ul><li>依赖机器的时间，如果机器时间不准或者回拨，可能导致重复</li></ul><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>在国内也得到了比较普遍的应用，各大厂根据其基本原理，生成了自己的规则：</p><ul><li>百度的uid-generator：<a href="https://github.com/baidu/uid-generator" target="_blank" rel="noopener">https://github.com/baidu/uid-generator</a></li><li>美团Leaf：<a href="https://github.com/zhuzhong/idleaf" target="_blank" rel="noopener">https://github.com/zhuzhong/idleaf</a></li></ul><h2 id="更多精彩内容，请关注我的微信公众号-互联网技术窝-或者加微信共同探讨交流："><a href="#更多精彩内容，请关注我的微信公众号-互联网技术窝-或者加微信共同探讨交流：" class="headerlink" title="更多精彩内容，请关注我的微信公众号 互联网技术窝  或者加微信共同探讨交流："></a>更多精彩内容，请关注我的微信公众号 <code>互联网技术窝</code>  或者加微信共同探讨交流：</h2><p>   <img src="https://i6448038.github.io/img/weichat/qrcode.jpg" alt></p><p>参考文献：<br>[flicker算法原文] <a href="http://code.flickr.com/blog/2010/02/08/ticket-servers-distributed-unique-primary-keys-on-the-cheap/" target="_blank" rel="noopener">http://code.flickr.com/blog/2010/02/08/ticket-servers-distributed-unique-primary-keys-on-the-cheap/</a></p><p>[分布式唯一ID极简教程] <a href="https://mp.weixin.qq.com/s/cqIK5Bv1U0mT97C7EOxmnA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/cqIK5Bv1U0mT97C7EOxmnA</a></p><p>[分布式 ID 生成策略] <a href="https://mp.weixin.qq.com/s/UAvSUDFJ8Fr0a-Na2Vr22g" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/UAvSUDFJ8Fr0a-Na2Vr22g</a></p><p>[分布式ID系列（2）——UUID适合做分布式ID吗] <a href="https://mp.weixin.qq.com/s/kZAnYz_Jj4aBrtsk8Q9w_A" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/kZAnYz_Jj4aBrtsk8Q9w_A</a></p><p><a href="https://segmentfault.com/a/1190000011282426" target="_blank" rel="noopener">https://segmentfault.com/a/1190000011282426</a></p><p><a href="https://juejin.im/post/5d6fc8eff265da03ef7a324b#comment" target="_blank" rel="noopener">https://juejin.im/post/5d6fc8eff265da03ef7a324b#comment</a></p><p><a href="https://segmentfault.com/a/1190000010978305" target="_blank" rel="noopener">https://segmentfault.com/a/1190000010978305</a></p><p>[Leaf——美团点评分布式ID生成系统] <a href="https://tech.meituan.com/2017/04/21/mt-leaf.html" target="_blank" rel="noopener">https://tech.meituan.com/2017/04/21/mt-leaf.html</a></p><p>[UUID的含义及实现原理]<a href="https://blog.csdn.net/reggergdsg/article/details/92091404" target="_blank" rel="noopener">https://blog.csdn.net/reggergdsg/article/details/92091404</a></p><p>[通用唯一标识码UUID的介绍及使用] <a href="https://mp.weixin.qq.com/s/BjCL076USuhLj9GjhXDaTA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/BjCL076USuhLj9GjhXDaTA</a><br>[UUID简史] <a href="https://www.infoq.cn/article/talk-about-the-history-of-uuid/?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="noopener">https://www.infoq.cn/article/talk-about-the-history-of-uuid/?utm_source=tuicool&amp;utm_medium=referral</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在分布式系统中，通常会用到分布式ID来标注数据的唯一性，而分布式ID的生成方式又多种多样，今天我们就来讨论一下主流的分布式ID生成策略。&lt;/p&gt;
&lt;h2 id=&quot;分布式ID基本需求&quot;&gt;&lt;a href=&quot;#分布式ID基本需求&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>图解Golang的内存分配</title>
    <link href="http://yoursite.com/2019/05/18/golang-mem/"/>
    <id>http://yoursite.com/2019/05/18/golang-mem/</id>
    <published>2019-05-18T10:15:56.000Z</published>
    <updated>2019-07-14T06:17:43.123Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一般程序的内存分配"><a href="#一般程序的内存分配" class="headerlink" title="一般程序的内存分配"></a>一般程序的内存分配</h2><p>在讲Golang的内存分配之前，让我们先来看看一般程序的内存分布情况：</p><p><img src="/img/go_mem/mem.png" alt></p><p>以上是程序内存的逻辑分类情况。</p><p>我们再来看看一般程序的内存的真实(真实逻辑)图:</p><p><img src="/img/go_mem/mem1.png" alt></p><h2 id="Go的内存分配核心思想"><a href="#Go的内存分配核心思想" class="headerlink" title="Go的内存分配核心思想"></a>Go的内存分配核心思想</h2><p>Go是内置运行时的编程语言(runtime)，像这种内置运行时的编程语言通常会抛弃传统的内存分配方式，改为自己管理。这样可以完成类似预分配、内存池等操作，以避开系统调用带来的性能问题，防止每次分配内存都需要系统调用。</p><p>Go的内存分配的核心思想可以分为以下几点：</p><ul><li>每次从操作系统申请一大块儿的内存，由Go来对这块儿内存做分配，减少系统调用</li><li>内存分配算法采用Google的<code>TCMalloc算法</code>。算法比较复杂，究其原理可自行查阅。其核心思想就是把内存切分的非常的细小，分为多级管理，以降低锁的粒度。</li><li>回收对象内存时，并没有将其真正释放掉，只是放回预先分配的大块内存中，以便复用。只有内存闲置过多的时候，才会尝试归还部分内存给操作系统，降低整体开销</li></ul><h2 id="Go的内存结构"><a href="#Go的内存结构" class="headerlink" title="Go的内存结构"></a>Go的内存结构</h2><p>Go在程序启动的时候，会分配一块连续的内存(虚拟内存)。整体如下：</p><p><img src="/img/go_mem/mem2.png" alt></p><p>图中span和bitmap的大小会随着heap的改变而改变</p><h3 id="arena"><a href="#arena" class="headerlink" title="arena"></a>arena</h3><p>arena区域就是我们通常所说的heap。<br>heap中按照管理和使用两个维度可认为存在两类“东西”：</p><p>一类是从管理分配角度，由多个连续的页(page)组成的大块内存：<br><img src="/img/go_mem/mem3.png" alt><br>另一类是从使用角度出发，就是平时咱们所了解的:heap中存在很多”对象”：<br><img src="/img/go_mem/mem4.png" alt></p><h3 id="spans"><a href="#spans" class="headerlink" title="spans"></a>spans</h3><p>spans区域，可以认为是用于上面所说的管理分配arena(即heap)的区域。<br>此区域存放了<code>mspan</code>的指针，<code>mspan</code>是啥后面会讲。<br>spans区域用于表示arena区中的某一页(page)属于哪个<code>mspan</code>。<br><img src="/img/go_mem/mem5.png" alt></p><p><code>mspan</code>可以说是go内存管理的最基本单元，但是内存的使用最终还是要落脚到“对象”上。<code>mspan</code>和对象是什么关系呢？<br>其实“对象”肯定也放到<code>page</code>中，毕竟<code>page</code>是内存存储的基本单元。</p><p>我们抛开问题不看，先看看一般情况下的对象和内存的分配是如何的：如下图<br><img src="/img/go_mem/mem6.png" alt></p><p>假如再分配“p4”的时候，是不是内存不足没法分配了？是不是有很多碎片？</p><p>这种一般的分配情况会出现内存碎片的情况，go是如何解决的呢？</p><p>可以归结为四个字：按需分配。go将内存块分为大小不同的67种，然后再把这67种大内存块，逐个分为小块(可以近似理解为大小不同的相当于<code>page</code>)称之为<code>span</code>(连续的<code>page</code>)，在go语言中就是上文提及的<code>mspan</code>。<br><img src="/img/go_mem/mem7.png" alt><br>对象分配的时候，根据对象的大小选择大小相近的<code>span</code>，这样，碎片问题就解决了。</p><p>67中不同大小的span代码注释如下(目前版本1.11)：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class  bytes/obj  bytes/span  objects  tail waste  max waste</span></span><br><span class="line"><span class="comment">//     1          8        8192     1024           0     87.50%</span></span><br><span class="line"><span class="comment">//     2         16        8192      512           0     43.75%</span></span><br><span class="line"><span class="comment">//     3         32        8192      256           0     46.88%</span></span><br><span class="line"><span class="comment">//     4         48        8192      170          32     31.52%</span></span><br><span class="line"><span class="comment">//     5         64        8192      128           0     23.44%</span></span><br><span class="line"><span class="comment">//     6         80        8192      102          32     19.07%</span></span><br><span class="line"><span class="comment">//     7         96        8192       85          32     15.95%</span></span><br><span class="line"><span class="comment">//     8        112        8192       73          16     13.56%</span></span><br><span class="line"><span class="comment">//     9        128        8192       64           0     11.72%</span></span><br><span class="line"><span class="comment">//    10        144        8192       56         128     11.82%</span></span><br><span class="line"><span class="comment">//    11        160        8192       51          32      9.73%</span></span><br><span class="line"><span class="comment">//    12        176        8192       46          96      9.59%</span></span><br><span class="line"><span class="comment">//    13        192        8192       42         128      9.25%</span></span><br><span class="line"><span class="comment">//    14        208        8192       39          80      8.12%</span></span><br><span class="line"><span class="comment">//    15        224        8192       36         128      8.15%</span></span><br><span class="line"><span class="comment">//    16        240        8192       34          32      6.62%</span></span><br><span class="line"><span class="comment">//    17        256        8192       32           0      5.86%</span></span><br><span class="line"><span class="comment">//    18        288        8192       28         128     12.16%</span></span><br><span class="line"><span class="comment">//    19        320        8192       25         192     11.80%</span></span><br><span class="line"><span class="comment">//    20        352        8192       23          96      9.88%</span></span><br><span class="line"><span class="comment">//    21        384        8192       21         128      9.51%</span></span><br><span class="line"><span class="comment">//    22        416        8192       19         288     10.71%</span></span><br><span class="line"><span class="comment">//    23        448        8192       18         128      8.37%</span></span><br><span class="line"><span class="comment">//    24        480        8192       17          32      6.82%</span></span><br><span class="line"><span class="comment">//    25        512        8192       16           0      6.05%</span></span><br><span class="line"><span class="comment">//    26        576        8192       14         128     12.33%</span></span><br><span class="line"><span class="comment">//    27        640        8192       12         512     15.48%</span></span><br><span class="line"><span class="comment">//    28        704        8192       11         448     13.93%</span></span><br><span class="line"><span class="comment">//    29        768        8192       10         512     13.94%</span></span><br><span class="line"><span class="comment">//    30        896        8192        9         128     15.52%</span></span><br><span class="line"><span class="comment">//    31       1024        8192        8           0     12.40%</span></span><br><span class="line"><span class="comment">//    32       1152        8192        7         128     12.41%</span></span><br><span class="line"><span class="comment">//    33       1280        8192        6         512     15.55%</span></span><br><span class="line"><span class="comment">//    34       1408       16384       11         896     14.00%</span></span><br><span class="line"><span class="comment">//    35       1536        8192        5         512     14.00%</span></span><br><span class="line"><span class="comment">//    36       1792       16384        9         256     15.57%</span></span><br><span class="line"><span class="comment">//    37       2048        8192        4           0     12.45%</span></span><br><span class="line"><span class="comment">//    38       2304       16384        7         256     12.46%</span></span><br><span class="line"><span class="comment">//    39       2688        8192        3         128     15.59%</span></span><br><span class="line"><span class="comment">//    40       3072       24576        8           0     12.47%</span></span><br><span class="line"><span class="comment">//    41       3200       16384        5         384      6.22%</span></span><br><span class="line"><span class="comment">//    42       3456       24576        7         384      8.83%</span></span><br><span class="line"><span class="comment">//    43       4096        8192        2           0     15.60%</span></span><br><span class="line"><span class="comment">//    44       4864       24576        5         256     16.65%</span></span><br><span class="line"><span class="comment">//    45       5376       16384        3         256     10.92%</span></span><br><span class="line"><span class="comment">//    46       6144       24576        4           0     12.48%</span></span><br><span class="line"><span class="comment">//    47       6528       32768        5         128      6.23%</span></span><br><span class="line"><span class="comment">//    48       6784       40960        6         256      4.36%</span></span><br><span class="line"><span class="comment">//    49       6912       49152        7         768      3.37%</span></span><br><span class="line"><span class="comment">//    50       8192        8192        1           0     15.61%</span></span><br><span class="line"><span class="comment">//    51       9472       57344        6         512     14.28%</span></span><br><span class="line"><span class="comment">//    52       9728       49152        5         512      3.64%</span></span><br><span class="line"><span class="comment">//    53      10240       40960        4           0      4.99%</span></span><br><span class="line"><span class="comment">//    54      10880       32768        3         128      6.24%</span></span><br><span class="line"><span class="comment">//    55      12288       24576        2           0     11.45%</span></span><br><span class="line"><span class="comment">//    56      13568       40960        3         256      9.99%</span></span><br><span class="line"><span class="comment">//    57      14336       57344        4           0      5.35%</span></span><br><span class="line"><span class="comment">//    58      16384       16384        1           0     12.49%</span></span><br><span class="line"><span class="comment">//    59      18432       73728        4           0     11.11%</span></span><br><span class="line"><span class="comment">//    60      19072       57344        3         128      3.57%</span></span><br><span class="line"><span class="comment">//    61      20480       40960        2           0      6.87%</span></span><br><span class="line"><span class="comment">//    62      21760       65536        3         256      6.25%</span></span><br><span class="line"><span class="comment">//    63      24576       24576        1           0     11.45%</span></span><br><span class="line"><span class="comment">//    64      27264       81920        3         128     10.00%</span></span><br><span class="line"><span class="comment">//    65      28672       57344        2           0      4.91%</span></span><br><span class="line"><span class="comment">//    66      32768       32768        1           0     12.50%</span></span><br></pre></td></tr></table></figure><p>说说每列代表的含义：</p><ul><li>class： class ID，每个span结构中都有一个class ID, 表示该span可处理的对象类型</li><li>bytes/obj：该class代表对象的字节数</li><li>bytes/span：每个span占用堆的字节数，也即页数*页大小</li><li>objects: 每个span可分配的对象个数，也即（bytes/spans）/（bytes/obj）</li><li>waste bytes: 每个span产生的内存碎片，也即（bytes/spans）%（bytes/obj）</li></ul><p>阅读方式如下：<br>以类型(class)为1的span为例,span中的元素大小是8 byte, span本身占1页也就是8K, 一共可以保存1024个对象。</p><p>细心的同学可能会发现代码中一共有66种，还有一种特殊的span：<br>即对于大于32k的对象出现时，会直接从heap分配一个特殊的span，这个特殊的span的类型(class)是0, 只包含了一个大对象, span的大小由对象的大小决定。</p><h3 id="bitmap"><a href="#bitmap" class="headerlink" title="bitmap"></a>bitmap</h3><p>bitmap 有好几种:Stack, data, and bss bitmaps，再就是这次要说的<code>heap bitmaps</code>。<br>在此bitmap的做作用是标记标记<code>arena</code>(即heap)中的对象。一是的标记对应地址中是否存在对象，另外是标记此对象是否被gc标记过。一个功能一个bit位，所以，<code>heap bitmaps</code>用两个bit位。<br>bitmap区域中的一个byte对应arena区域的四个指针大小的内存的结构如下：</p><p><img src="/img/go_mem/mem8.png" alt></p><p>bitmap的地址是由高地址向低地址增长的。</p><p>宏观的图为：</p><p><img src="/img/go_mem/mem9.png" alt><br>bitmap 主要的作用还是服务于GC。</p><p><code>arena</code>中包含基本的管理单元和程序运行时候生成的对象或实体，这两部分分别被<code>spans</code>和<code>bitmap</code>这两块非heap区域的内存所对应着。<br>逻辑图如下：<br><img src="/img/go_mem/mem10.png" alt><br>spans和bitmap都会根据arena的动态变化而动态调整大小。</p><h2 id="内存管理组件"><a href="#内存管理组件" class="headerlink" title="内存管理组件"></a>内存管理组件</h2><p>go的内存管理组件主要有：<code>mspan</code>、<code>mcache</code>、<code>mcentral</code>和<code>mheap</code></p><ul><li><code>mspan</code>为内存管理的基础单元，直接存储数据的地方。</li><li><code>mcache</code>：每个运行期的goroutine都会绑定的一个<code>mcache</code>(具体来讲是绑定的GMP并发模型中的P，所以可以无锁分配<code>mspan</code>，后续还会说到)，<code>mcache</code>会分配goroutine运行中所需要的内存空间(即<code>mspan</code>)。</li><li><code>mcentral</code>为所有<code>mcache</code>切分好后备的<code>mspan</code></li><li><code>mheap</code>代表Go程序持有的所有堆空间。还会管理闲置的span，需要时向操作系统申请新内存。</li></ul><h3 id="mspan"><a href="#mspan" class="headerlink" title="mspan"></a>mspan</h3><p><img src="/img/go_mem/mem11.png" alt><br>有人会问：mspan结构体存放在哪儿？其实，mspan结构本身的内存是从系统分配的，在此不做过多讨论。<br><code>mspan</code>在上文讲<code>spans</code>的时候具体讲过，就是方便根据对象大小来分配使用的内存块，一共有67种类型；最主要解决的是内存碎片问题，减少了内存碎片，提高了内存使用率。<br><code>mspan</code>是双向链表，其中主要的属性如下图所示：<br><img src="/img/go_mem/mem12.png" alt></p><p><code>mspan</code>是go中内存管理的基本单元，在上文<code>spans</code>中其实已经做了详细的解说，在此就不在赘述了。</p><h3 id="mcache"><a href="#mcache" class="headerlink" title="mcache"></a>mcache</h3><p>为了避免多线程申请内存时不断的加锁，goroutine为每个线程分配了<code>span</code>内存块的缓存，这个缓存即是<code>mcache</code>，每个goroutine都会绑定的一个<code>mcache</code>，各个goroutine申请内存时不存在锁竞争的情况。</p><p>如何做到的？</p><p>在讲之前，请先回顾一下Go的并发调度模型，如果你还不了解，请看我这篇文章 <a href="https://mp.weixin.qq.com/s/74hbRTQ2TjdH5G9F2of4_g" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/74hbRTQ2TjdH5G9F2of4_g</a></p><p>然后请看下图：</p><p><img src="/img/go_mem/mem13.png" alt></p><p>大体上就是上图这个样子了。注意看我们的<code>mcache</code>在哪儿呢？就在P上！<br>知道为什么没有锁竞争了吧，因为运行期间一个goroutine只能和一个P关联，而<code>mcache</code>就在P上，所以，不可能有锁的竞争。</p><p>我们再来看看<code>mcache</code>具体的结构：</p><p><img src="/img/go_mem/mem14.png" alt></p><p>mcache中的span链表分为两组，一组是包含指针类型的对象，另一组是不包含指针类型的对象。为什么分开呢？</p><p>主要是方便GC，在进行垃圾回收的时候，对于不包含指针的对象列表无需进一步扫描是否引用其他活跃的对象(如果对go的gc不是很了解，请看我这篇文章 <a href="https://mp.weixin.qq.com/s/_h0-8hma5y_FHKBeFuOOyw)。" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/_h0-8hma5y_FHKBeFuOOyw)。</a></p><p>对于 <code>&lt;=32k</code>的对象，将直接通过<code>mcache</code>分配。</p><p>在此，我觉的有必要说一下go中对象按照的大小维度的分类。<br>分为三类：</p><ul><li>tinny allocations (size &lt; 16 bytes，no pointers)</li><li>small allocations (16 bytes &lt; size &lt;= 32k)</li><li>large allocations (size &gt; 32k)</li></ul><p>前两类：<code>tiny allocations</code>和<code>small allocations</code>是直接通过<code>mcache</code>来分配的。</p><p>对于<code>tiny allocations</code>的分配，有一个微型分配器<code>tiny allocator</code>来分配，分配的对象都是不包含指针的，例如一些小的字符串和不包含指针的独立的逃逸变量等。</p><p><code>small allocations</code>的分配，就是<code>mcache</code>根据对象的大小来找自身存在的大小相匹配<code>mspan</code>来分配。<br>当<code>mcach</code>没有可用空间时，会从<code>mcentral</code>的 <code>mspans</code> 列表获取一个新的所需大小规格的<code>mspan</code>。</p><h3 id="mcentral"><a href="#mcentral" class="headerlink" title="mcentral"></a>mcentral</h3><p>为所有<code>mcache</code>提供切分好的<code>mspan</code>。<br>每个<code>mcentral</code>保存一种特定类型的全局<code>mspan</code>列表，包括已分配出去的和未分配出去的。 </p><p><img src="/img/go_mem/mem15.png" alt></p><p>还记得<code>mspan</code>的67种类型吗？有多少种类型的<code>mspan</code>就有多少个<code>mcentral</code>。</p><p>每个<code>mcentral</code>都会包含两个<code>mspan</code>的列表：</p><ul><li>没有空闲对象或<code>mspan</code>已经被<code>mcache</code>缓存的<code>mspan</code>列表(empty mspanList)</li><li>有空闲对象的<code>mspan</code>列表(empty mspanList)</li></ul><p>由于<code>mspan</code>是全局的，会被所有的<code>mcache</code>访问，所以会出现并发性问题，因而<code>mcentral</code>会存在一个锁。</p><p>单个的<code>mcentral</code>结构如下：<br><img src="/img/go_mem/mem16.png" alt></p><p>假如需要分配内存时，<code>mcentral</code>没有空闲的<code>mspan</code>列表了，此时需要向<code>mheap</code>去获取。</p><h3 id="mheap"><a href="#mheap" class="headerlink" title="mheap"></a>mheap</h3><p><code>mheap</code>可以认为是Go程序持有的整个堆空间，<code>mheap</code>全局唯一，可以认为是个全局变量。<br>其结构如下：</p><p><img src="/img/go_mem/mem17.png" alt></p><p><code>mheap</code>包含了除了上文中讲的<code>mcache</code>之外的一切，<code>mcache</code>是存在于Go的GMP调度模型的P中的，上文中已经讲过了，关于GMP并发模型，可以参考我的文章 <a href="https://mp.weixin.qq.com/s/74hbRTQ2TjdH5G9F2of4_g。" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/74hbRTQ2TjdH5G9F2of4_g。</a><br>仔细观察，可以发现<code>mheap</code>中也存在一个锁lock。这个lock是作用是什么呢？</p><p>我们知道，大于32K的对象被定义为大对象，直接通过<code>mheap</code> 分配。这些大对象的申请是由<code>mcache</code>发出的，而<code>mcache</code>在P上，程序运行的时候往往会存在多个P，因此，这个内存申请是并发的；所以为了保证线程安全，必须有一个全局锁。</p><p>假如需要分配的内存时，<code>mheap</code>中也没有了，则向操作系统申请一系列新的页（最小 1MB）。</p><h2 id="Go内存分配流程总结"><a href="#Go内存分配流程总结" class="headerlink" title="Go内存分配流程总结"></a>Go内存分配流程总结</h2><p>对象分三种：</p><ul><li>微小对象，size &lt; 16B</li><li>一般小对象， 16 bytes &lt; size &lt;= 32k</li><li>大对象 size &gt; 32k</li></ul><p>分配方式分三种：</p><ul><li>tinny allocations (size &lt; 16 bytes，no pointers) 微型分配器分配。</li><li>small allocations ( size &lt;= 32k) 正常分配；首先通过计算使用的大小规格，然后使用 mcache 中对应大小规格的块分配</li><li>large allocations (size &gt; 32k) 大对象分配；直接通过<code>mheap</code>分配。这些大对象的申请是以一个全局锁为代价的，因此任何给定的时间点只能同时供一个 P 申请。</li></ul><p>对象分配：</p><ul><li>size范围在在( size &lt; 16B)，不包含指针的对象。 <code>mcache</code>上的微型分配器分配</li><li>size范围在(0 &lt; size &lt; 16B)， 包含指针的对象：正常分配</li><li>size范围在(16B &lt; size &lt;= 32KB)， : 正常分配</li><li>size范围在( size &gt; 32KB) : 大对象分配 </li></ul><p>分配顺序：</p><ul><li>首先通过计算使用的大小规格。</li><li>然后使用<code>mcache</code>中对应大小规格的块分配。</li><li>如果<code>mcentral</code>中没有可用的块，则向<code>mheap</code>申请，并根据算法找到最合适的<code>mspan</code>。</li><li>如果申请到的<code>mspan</code> 超出申请大小，将会根据需求进行切分，以返回用户所需的页数。剩余的页构成一个新的 mspan 放回 mheap 的空闲列表。</li><li>如果 mheap 中没有可用 span，则向操作系统申请一系列新的页（最小 1MB）。</li></ul><p>Go的内存管理是非常复杂的，且每个版本都有细微的变化，在此，只讲了些最容易宏观掌握的东西，希望大家多多提意见，如有什么问题，请及时与我沟通，以下是联系方式：</p><h2 id="请关注我的微信公众号-互联网技术窝，问题直接在公众号内留言即可"><a href="#请关注我的微信公众号-互联网技术窝，问题直接在公众号内留言即可" class="headerlink" title="请关注我的微信公众号 互联网技术窝，问题直接在公众号内留言即可"></a>请关注我的微信公众号 <code>互联网技术窝</code>，问题直接在公众号内留言即可</h2><p>   <img src="https://i6448038.github.io/img/weichat/qrcode.jpg" alt></p><p>参考文献:</p><ul><li>程序在内存中的分布 <a href="https://www.cnblogs.com/Lynn-Zhang/p/5449199.html" target="_blank" rel="noopener">https://www.cnblogs.com/Lynn-Zhang/p/5449199.html</a></li><li>从内存分配开始 <a href="https://mp.weixin.qq.com/s/EyWKFRu1xryoHY386QUcuA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/EyWKFRu1xryoHY386QUcuA</a></li><li>译文：Go 内存分配器可视化指南 <a href="https://www.linuxzen.com/go-memory-allocator-visual-guide.html" target="_blank" rel="noopener">https://www.linuxzen.com/go-memory-allocator-visual-guide.html</a></li><li>图解Go语言内存分配 <a href="https://juejin.im/post/5c888a79e51d456ed11955a8" target="_blank" rel="noopener">https://juejin.im/post/5c888a79e51d456ed11955a8</a></li><li>Golang源码探索(三) GC的实现原理 <a href="https://www.cnblogs.com/zkweb/p/7880099.html" target="_blank" rel="noopener">https://www.cnblogs.com/zkweb/p/7880099.html</a></li><li>简单易懂的 Go 内存分配原理解读 <a href="https://yq.aliyun.com/articles/652551" target="_blank" rel="noopener">https://yq.aliyun.com/articles/652551</a></li><li>雨痕&lt;&lt;Go源码解析&gt;&gt;</li><li>go内存分配(英文) <a href="https://andrestc.com/post/go-memory-allocation-pt1/" target="_blank" rel="noopener">https://andrestc.com/post/go-memory-allocation-pt1/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一般程序的内存分配&quot;&gt;&lt;a href=&quot;#一般程序的内存分配&quot; class=&quot;headerlink&quot; title=&quot;一般程序的内存分配&quot;&gt;&lt;/a&gt;一般程序的内存分配&lt;/h2&gt;&lt;p&gt;在讲Golang的内存分配之前，让我们先来看看一般程序的内存分布情况：&lt;/p&gt;
&lt;p
      
    
    </summary>
    
    
      <category term="golang" scheme="http://yoursite.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>图解字符编码</title>
    <link href="http://yoursite.com/2019/04/24/character/"/>
    <id>http://yoursite.com/2019/04/24/character/</id>
    <published>2019-04-24T14:04:05.000Z</published>
    <updated>2019-07-14T06:17:43.116Z</updated>
    
    <content type="html"><![CDATA[<h2 id="啥叫字符集"><a href="#啥叫字符集" class="headerlink" title="啥叫字符集"></a>啥叫字符集</h2><p>计算机只认识0和1</p><p><img src="/img/character/c_1.png" alt></p><p>那字符串“abc”咋显示呢？<br>有个类似于字典的东西，告诉计算机在此种情况（在此编码格式）下，某些数字该显示什么。</p><p><img src="/img/character/c_2.png" alt></p><p>这种字典，就是字符集</p><p><img src="/img/character/c_3.png" alt></p><h2 id="现有的字符集"><a href="#现有的字符集" class="headerlink" title="现有的字符集"></a>现有的字符集</h2><p>目前主要有以下几种字符集：</p><ul><li>ASCII字符集</li><li>ISO 8859-1字符集</li><li>GB2312字符集</li><li>GBK字符集</li><li>Unicode编码</li></ul><h3 id="ASCII字符集"><a href="#ASCII字符集" class="headerlink" title="ASCII字符集"></a>ASCII字符集</h3><p>共收录128个字符，都是些最最基础的字符。详情请看<a href="https://baike.baidu.com/item/ASCII/309296?fr=aladdin" target="_blank" rel="noopener">百度百科</a> </p><p><em>大小：占一个字节</em></p><h3 id="ISO-8859-1字符集-别名latin1"><a href="#ISO-8859-1字符集-别名latin1" class="headerlink" title="ISO 8859-1字符集(别名latin1)"></a>ISO 8859-1字符集(别名latin1)</h3><p><em>ASCII字符集的扩充</em>。共收录256个字符。ASCII字符集基础上扩充了128个西欧常用字符(包括德法两国的字母)</p><p><em>大小：占一个字节</em></p><h3 id="GB2312字符集"><a href="#GB2312字符集" class="headerlink" title="GB2312字符集"></a>GB2312字符集</h3><p><em>划重点：made in china</em>。<br>百度百科~曰：”共收录6763个汉字，其中一级汉字3755个，二级汉字3008个；同时，GB 2312收录了包括拉丁字母、希腊字母、日文平假名及片假名字母、俄语西里尔字母在内的682个全角字符。“详情请看<a href="https://baike.baidu.com/item/%E4%BF%A1%E6%81%AF%E4%BA%A4%E6%8D%A2%E7%94%A8%E6%B1%89%E5%AD%97%E7%BC%96%E7%A0%81%E5%AD%97%E7%AC%A6%E9%9B%86/8074272?fr=aladdin" target="_blank" rel="noopener">百度百科</a> </p><p>兼容ASCII字符集。</p><p><em>大小：如果该字符在ASCII字符集中，则采用1字节编码。否则采用2字节编码。</em></p><h3 id="GBK字符集"><a href="#GBK字符集" class="headerlink" title="GBK字符集"></a>GBK字符集</h3><p><em>划重点：made in china</em>。<br>继<code>GB2312字符集</code>之后中国又出的一套标准。这套更牛逼：不仅完全兼容GB2312字符集。还扩充了很多：<br>”共23940个码位，共收录了21003个汉字…全部中日韩汉字…“ 总之一个字：牛逼！</p><p><em>大小：如果该字符在ASCII字符集中，则采用1字节编码。否则采用2字节编码。</em></p><h3 id="Unicode编码。"><a href="#Unicode编码。" class="headerlink" title="Unicode编码。"></a>Unicode编码。</h3><p>牛逼的玩意儿来了。先看看它的中文译名：统一码、万国码、单一码。<br>收录地球上的所有字符，现在还在不断扩充。<br><em>但是，需要注意的是，Unicode只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。</em></p><p><img src="/img/character/c_4.png" alt></p><p>其中，Unicode编码规定的符号代码必须以”U+”做前缀。</p><p>编号怎么对应到二进制表示呢？有多种方案：主要有 UTF-8，UTF-16，UTF-32。</p><ul><li>UTF-32字符集。将unicode编码的码号直接转成对应的二进制数。<em>大小：4个字节</em>。</li><li>UTF-16字符集。使用变长字节表示。<em>大小：对于编号在 U+0000 到 U+FFFF 的字符（常用字符集），直接用两个字节表示，其余的用4个字节</em></li><li>UTF-8字符集。使用变长字节表示。兼容ASCII字符集。<em>大小:1~4个字节</em></li></ul><h2 id="字符集之间的关系"><a href="#字符集之间的关系" class="headerlink" title="字符集之间的关系"></a>字符集之间的关系</h2><p><img src="/img/character/c_6.png" alt></p><p>参考文献:</p><ul><li>掘金小册《MySQL 是怎样运行的：从根儿上理解 MySQL》</li><li><a href="https://blog.csdn.net/zhusongziye/article/details/84261211" target="_blank" rel="noopener">https://blog.csdn.net/zhusongziye/article/details/84261211</a></li><li><a href="https://www.cnblogs.com/kingstarspe/p/ASCII.html" target="_blank" rel="noopener">https://www.cnblogs.com/kingstarspe/p/ASCII.html</a></li></ul><h2 id="更多精彩内容，请关注我的微信公众号-互联网技术窝-或者加微信共同探讨交流："><a href="#更多精彩内容，请关注我的微信公众号-互联网技术窝-或者加微信共同探讨交流：" class="headerlink" title="更多精彩内容，请关注我的微信公众号 互联网技术窝  或者加微信共同探讨交流："></a>更多精彩内容，请关注我的微信公众号 <code>互联网技术窝</code>  或者加微信共同探讨交流：</h2><p>   <img src="https://i6448038.github.io/img/weichat/qrcode.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;啥叫字符集&quot;&gt;&lt;a href=&quot;#啥叫字符集&quot; class=&quot;headerlink&quot; title=&quot;啥叫字符集&quot;&gt;&lt;/a&gt;啥叫字符集&lt;/h2&gt;&lt;p&gt;计算机只认识0和1&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/character/c_1.png&quot; alt&gt;&lt;/p
      
    
    </summary>
    
    
      <category term="字符集" scheme="http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>图解Go的channel底层实现</title>
    <link href="http://yoursite.com/2019/04/11/go-channel/"/>
    <id>http://yoursite.com/2019/04/11/go-channel/</id>
    <published>2019-04-11T15:43:20.000Z</published>
    <updated>2019-07-14T06:17:43.124Z</updated>
    
    <content type="html"><![CDATA[<p>废话不多说，直奔主题。</p><h2 id="channel的整体结构图"><a href="#channel的整体结构图" class="headerlink" title="channel的整体结构图"></a>channel的整体结构图</h2><p><img src="/img/channel/hchan.png" alt></p><p>简单说明：</p><ul><li><code>buf</code>是有缓冲的channel所特有的结构，用来存储缓存数据。是个循环链表</li><li><code>sendx</code>和<code>recvx</code>用于记录<code>buf</code>这个循环链表中的<del>发送或者接收的</del>index</li><li><code>lock</code>是个互斥锁。</li><li><code>recvq</code>和<code>sendq</code>分别是接收(&lt;-channel)或者发送(channel &lt;- xxx)的goroutine抽象出来的结构体(sudog)的队列。是个双向链表</li></ul><p>源码位于<code>/runtime/chan.go</code>中(目前版本：1.11)。结构体为<code>hchan</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">    qcount   <span class="keyword">uint</span>           <span class="comment">// total data in the queue</span></span><br><span class="line">    dataqsiz <span class="keyword">uint</span>           <span class="comment">// size of the circular queue</span></span><br><span class="line">    buf      unsafe.Pointer <span class="comment">// points to an array of dataqsiz elements</span></span><br><span class="line">    elemsize <span class="keyword">uint16</span></span><br><span class="line">    closed   <span class="keyword">uint32</span></span><br><span class="line">    elemtype *_type <span class="comment">// element type</span></span><br><span class="line">    sendx    <span class="keyword">uint</span>   <span class="comment">// send index</span></span><br><span class="line">    recvx    <span class="keyword">uint</span>   <span class="comment">// receive index</span></span><br><span class="line">    recvq    waitq  <span class="comment">// list of recv waiters</span></span><br><span class="line">    sendq    waitq  <span class="comment">// list of send waiters</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// lock protects all fields in hchan, as well as several</span></span><br><span class="line">    <span class="comment">// fields in sudogs blocked on this channel.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Do not change another G's status while holding this lock</span></span><br><span class="line">    <span class="comment">// (in particular, do not ready a G), as this can deadlock</span></span><br><span class="line">    <span class="comment">// with stack shrinking.</span></span><br><span class="line">    lock mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们来详细介绍<code>hchan</code>中各部分是如何使用的。</p><h2 id="先从创建开始"><a href="#先从创建开始" class="headerlink" title="先从创建开始"></a>先从创建开始</h2><p>我们首先创建一个channel。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p><img src="/img/channel/hchan1.png" alt></p><p>创建channel实际上就是在内存中实例化了一个<code>hchan</code>的结构体，并返回一个ch指针，我们使用过程中channel在函数之间的传递都是用的这个指针，这就是为什么函数传递中无需使用channel的指针，而直接用channel就行了，因为channel本身就是一个指针。</p><h2 id="channel中发送send-ch-lt-xxx-和recv-lt-ch-接收"><a href="#channel中发送send-ch-lt-xxx-和recv-lt-ch-接收" class="headerlink" title="channel中发送send(ch &lt;- xxx)和recv(&lt;- ch)接收"></a>channel中发送send(ch &lt;- xxx)和recv(&lt;- ch)接收</h2><p>先考虑一个问题，如果你想让goroutine以先进先出(FIFO)的方式进入一个结构体中，你会怎么操作？<br>加锁！对的！channel就是用了一个锁。hchan本身包含一个互斥锁<code>mutex</code></p><h3 id="channel中队列是如何实现的"><a href="#channel中队列是如何实现的" class="headerlink" title="channel中队列是如何实现的"></a>channel中队列是如何实现的</h3><p>channel中有个缓存buf，是用来缓存数据的(假如实例化了带缓存的channel的话)队列。我们先来看看是如何实现“队列”的。<br>还是刚才创建的那个channel</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p><img src="/img/channel/hchan_gif1.png" alt></p><p>当使用<code>send (ch &lt;- xx)</code>或者<code>recv ( &lt;-ch)</code>的时候，首先要锁住<code>hchan</code>这个结构体。</p><p><img src="/img/channel/hchan_gif2.png" alt></p><p>然后开始<code>send (ch &lt;- xx)</code>数据。<br>一</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- <span class="number">1</span></span><br></pre></td></tr></table></figure><p>二</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- <span class="number">1</span></span><br></pre></td></tr></table></figure><p>三</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- <span class="number">1</span></span><br></pre></td></tr></table></figure><p>这时候满了，队列塞不进去了<br>动态图表示为：<br><img src="/img/channel/send.gif" alt></p><p>然后是取<code>recv ( &lt;-ch)</code>的过程，是个逆向的操作，也是需要加锁。</p><p><img src="/img/channel/hchan_gif6.png" alt></p><p>然后开始<code>recv (&lt;-ch)</code>数据。<br>一</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;-ch</span><br></pre></td></tr></table></figure><p>二</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;-ch</span><br></pre></td></tr></table></figure><p>三</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;-ch</span><br></pre></td></tr></table></figure><p>图为：<br><img src="/img/channel/recv.gif" alt></p><p>注意以上两幅图中<code>buf</code>和<code>recvx</code>以及<code>sendx</code>的变化，<code>recvx</code>和<code>sendx</code>是根据循环链表<code>buf</code>的变动而改变的。<br>至于为什么channel会使用循环链表作为缓存结构，我个人认为是在缓存列表在动态的<code>send</code>和<code>recv</code>过程中，定位当前<code>send</code>或者<code>recvx</code>的位置、选择<code>send</code>的和<code>recvx</code>的位置比较方便吧，只要顺着链表顺序一直旋转操作就好。</p><p>缓存中按链表顺序存放，取数据的时候按链表顺序读取，符合FIFO的原则。</p><h3 id="send-recv的细化操作"><a href="#send-recv的细化操作" class="headerlink" title="send/recv的细化操作"></a>send/recv的细化操作</h3><p>注意：缓存链表中以上每一步的操作，都是需要加锁操作的！</p><p>每一步的操作的细节可以细化为：</p><ul><li>第一，加锁</li><li>第二，把数据从goroutine中copy到“队列”中(或者从队列中copy到goroutine中）。</li><li>第三，释放锁</li></ul><p>每一步的操作总结为动态图为：(发送过程)<br><img src="/img/channel/send_single.gif" alt></p><p>或者为：(接收过程)<br><img src="/img/channel/recv_single.gif" alt></p><p>所以不难看出，Go中那句经典的话：<code>Do not communicate by sharing memory; instead, share memory by communicating.</code>的具体实现就是利用channel把数据从一端copy到了另一端！<br>还真是符合<code>channel</code>的英文含义：</p><p><img src="/img/channel/hchan_channl.gif" alt></p><h3 id="当channel缓存满了之后会发生什么？这其中的原理是怎样的？"><a href="#当channel缓存满了之后会发生什么？这其中的原理是怎样的？" class="headerlink" title="当channel缓存满了之后会发生什么？这其中的原理是怎样的？"></a>当channel缓存满了之后会发生什么？这其中的原理是怎样的？</h3><p>使用的时候，我们都知道，当channel缓存满了，或者没有缓存的时候，我们继续send(ch &lt;- xxx)或者recv(&lt;- ch)会阻塞当前goroutine，但是，是如何实现的呢？</p><p>我们知道，Go的goroutine是用户态的线程(<code>user-space threads</code>)，用户态的线程是需要自己去调度的，Go有运行时的scheduler去帮我们完成调度这件事情。关于Go的调度模型GMP模型我在此不做赘述，如果不了解，可以看我另一篇文章(<a href="https://i6448038.github.io/2017/12/04/golang-concurrency-principle/" target="_blank" rel="noopener">Go调度原理</a>)</p><p>goroutine的阻塞操作，实际上是调用<code>send (ch &lt;- xx)</code>或者<code>recv ( &lt;-ch)</code>的时候主动触发的，具体请看以下内容：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//goroutine1 中，记做G1</span></span><br><span class="line"></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">ch &lt;- <span class="number">1</span></span><br><span class="line">ch &lt;- <span class="number">1</span></span><br><span class="line">ch &lt;- <span class="number">1</span></span><br></pre></td></tr></table></figure><p><img src="/img/channel/hchan_block.png" alt></p><p><img src="/img/channel/hchan_block1.png" alt></p><p>这个时候G1正在正常运行,当再次进行send操作(ch&lt;-1)的时候，会主动调用Go的调度器,让G1等待，并从让出M，让其他G去使用</p><p><img src="/img/channel/hchan_block2.png" alt></p><p>同时G1也会被抽象成含有G1指针和send元素的<code>sudog</code>结构体保存到hchan的<code>sendq</code>中等待被唤醒。</p><p><img src="/img/channel/hchan_blok3.gif" alt></p><p>那么，G1什么时候被唤醒呢？这个时候G2隆重登场。</p><p><img src="/img/channel/hchan_block4.png" alt></p><p>G2执行了recv操作<code>p := &lt;-ch</code>，于是会发生以下的操作：</p><p><img src="/img/channel/hchan_block5.gif" alt></p><p>G2从缓存队列中取出数据，channel会将等待队列中的G1推出，将G1当时send的数据推到缓存中，然后调用Go的scheduler，唤醒G1，并把G1放到可运行的Goroutine队列中。</p><p><img src="/img/channel/hchan_block6.gif" alt></p><h3 id="假如是先进行执行recv操作的G2会怎么样？"><a href="#假如是先进行执行recv操作的G2会怎么样？" class="headerlink" title="假如是先进行执行recv操作的G2会怎么样？"></a>假如是先进行执行recv操作的G2会怎么样？</h3><p>你可能会顺着以上的思路反推。首先：</p><p><img src="/img/channel/hchan_block7_1.png" alt></p><p>这个时候G2会主动调用Go的调度器,让G2等待，并从让出M，让其他G去使用。<br>G2还会被抽象成含有G2指针和recv空元素的<code>sudog</code>结构体保存到hchan的<code>recvq</code>中等待被唤醒</p><p><img src="/img/channel/hchan_block7.gif" alt></p><p>此时恰好有个goroutine G1开始向channel中推送数据 <code>ch &lt;- 1</code>。<br>此时，非常有意思的事情发生了：</p><p><img src="/img/channel/hchan_block8.gif" alt></p><p>G1并没有锁住channel，然后将数据放到缓存中，而是直接把数据从G1直接copy到了G2的栈中。<br>这种方式非常的赞！在唤醒过程中，G2无需再获得channel的锁，然后从缓存中取数据。减少了内存的copy，提高了效率。</p><p>之后的事情显而易见：<br><img src="/img/channel/hchan_block9.gif" alt></p><h2 id="更多精彩内容，请关注我的微信公众号-互联网技术窝-或者加微信共同探讨交流："><a href="#更多精彩内容，请关注我的微信公众号-互联网技术窝-或者加微信共同探讨交流：" class="headerlink" title="更多精彩内容，请关注我的微信公众号 互联网技术窝  或者加微信共同探讨交流："></a>更多精彩内容，请关注我的微信公众号 <code>互联网技术窝</code>  或者加微信共同探讨交流：</h2><p>   <img src="https://i6448038.github.io/img/weichat/qrcode.jpg" alt></p><p>参考文献：</p><ul><li><a href="https://www.youtube.com/watch?v=KBZlN0izeiY" target="_blank" rel="noopener">https://www.youtube.com/watch?v=KBZlN0izeiY</a></li><li><a href="https://zhuanlan.zhihu.com/p/27917262" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/27917262</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;废话不多说，直奔主题。&lt;/p&gt;
&lt;h2 id=&quot;channel的整体结构图&quot;&gt;&lt;a href=&quot;#channel的整体结构图&quot; class=&quot;headerlink&quot; title=&quot;channel的整体结构图&quot;&gt;&lt;/a&gt;channel的整体结构图&lt;/h2&gt;&lt;p&gt;&lt;img sr
      
    
    </summary>
    
    
      <category term="golang" scheme="http://yoursite.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>图解Go select语句原理</title>
    <link href="http://yoursite.com/2019/03/23/go-select-principle/"/>
    <id>http://yoursite.com/2019/03/23/go-select-principle/</id>
    <published>2019-03-23T12:08:40.000Z</published>
    <updated>2019-07-14T06:17:43.148Z</updated>
    
    <content type="html"><![CDATA[<p>Go 的select语句是一种仅能用于channl发送和接收消息的专用语句，此语句运行期间是阻塞的；当select中没有case语句的时候，会阻塞当前的groutine。所以，有人也会说select是用来阻塞监听goroutine的。<br>还有人说：select是Golang在语言层面提供的I/O多路复用的机制，其专门用来检测多个channel是否准备完毕：可读或可写。</p><p>以上说法都正确。</p><h2 id="I-O多路复用"><a href="#I-O多路复用" class="headerlink" title="I/O多路复用"></a>I/O多路复用</h2><p>我们来回顾一下是什么是<code>I/O多路复用</code>。</p><h3 id="普通多线程（或进程）I-O"><a href="#普通多线程（或进程）I-O" class="headerlink" title="普通多线程（或进程）I/O"></a>普通多线程（或进程）I/O</h3><p><img src="/img/select_priciple/select-principle_0.png" alt></p><p>每来一个进程，都会建立连接，然后阻塞，直到接收到数据返回响应。<br>普通这种方式的缺点其实很明显：系统需要创建和维护额外的线程或进程。因为大多数时候，大部分阻塞的线程或进程是处于等待状态，只有少部分会接收并处理响应，而其余的都在等待。系统为此还需要多做很多额外的线程或者进程的管理工作。</p><p><img src="/img/select_priciple/select-principle_1.png" alt></p><p>为了解决图中这些多余的线程或者进程，于是有了”I/O多路复用”</p><h3 id="I-O多路复用-1"><a href="#I-O多路复用-1" class="headerlink" title="I/O多路复用"></a>I/O多路复用</h3><p><img src="/img/select_priciple/select-principle_2.png" alt></p><p>每个线程或者进程都先到图中”装置“中注册，然后阻塞，然后只有一个线程在”运输“，当注册的线程或者进程准备好数据后，”装置“会根据注册的信息得到相应的数据。从始至终kernel只会使用图中这个黄黄的线程，无需再对额外的线程或者进程进行管理，提升了效率。</p><h2 id="select组成结构"><a href="#select组成结构" class="headerlink" title="select组成结构"></a>select组成结构</h2><p>select的实现经历了多个版本的修改，当前版本为：1.11<br>select这个语句底层实现实际上主要由两部分组成：<code>case语句</code>和<code>执行函数</code>。<br>源码地址为：/go/src/runtime/select.go</p><p>每个case语句，单独抽象出以下结构体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> scase <span class="keyword">struct</span> &#123;</span><br><span class="line">    c           *hchan         <span class="comment">// chan</span></span><br><span class="line">    elem        unsafe.Pointer <span class="comment">// 读或者写的缓冲区地址</span></span><br><span class="line">    kind        <span class="keyword">uint16</span>   <span class="comment">//case语句的类型，是default、传值写数据(channel &lt;-) 还是  取值读数据(&lt;- channel)</span></span><br><span class="line">    pc          <span class="keyword">uintptr</span> <span class="comment">// race pc (for race detector / msan)</span></span><br><span class="line">    releasetime <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结构体可以用下图表示：</p><p><img src="/img/select_priciple/select-principle_3.png" alt><br>其中比较关键的是：<code>hchan</code>，它是channel的指针。<br>在一个select中，所有的case语句会构成一个<code>scase</code>结构体的数组。</p><p><img src="/img/select_priciple/select-principle_4.png" alt></p><p>然后执行select语句实际上就是调用<code>func selectgo(cas0 *scase, order0 *uint16, ncases int) (int, bool)</code>函数。</p><p><img src="/img/select_priciple/select-principle_5.png" alt></p><p><code>func selectgo(cas0 *scase, order0 *uint16, ncases int) (int, bool)</code>函数参数：</p><ul><li>cas0 为上文提到的case语句抽象出的结构体<code>scase</code>数组的第一个元素地址</li><li>order0为一个两倍cas0数组长度的buffer，保存scase随机序列pollorder和scase中channel地址序列lockorder。</li><li>nncases表示<code>scase</code>数组的长度</li></ul><p><code>selectgo</code>返回所选scase的索引(该索引与其各自的select {recv，send，default}调用的序号位置相匹配)。此外，如果选择的scase是接收操作(recv)，则返回是否接收到值。</p><p>谁负责调用<code>func selectgo(cas0 *scase, order0 *uint16, ncases int) (int, bool)</code>函数呢？</p><p>在<code>/reflect/value.go</code>中有个<code>func rselect([]runtimeSelect) (chosen int, recvOK bool)</code>函数，此函数的实现在<code>/runtime/select.go</code>文件中的<code>func reflect_rselect(cases []runtimeSelect) (int, bool)</code>函数中:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflect_rselect</span><span class="params">(cases []runtimeSelect)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">bool</span>)</span></span> &#123; </span><br><span class="line">    <span class="comment">//如果cases语句为空，则阻塞当前groutine</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(cases) == <span class="number">0</span> &#123;</span><br><span class="line">        block()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//实例化case的结构体</span></span><br><span class="line">    sel := <span class="built_in">make</span>([]scase, <span class="built_in">len</span>(cases))</span><br><span class="line">    order := <span class="built_in">make</span>([]<span class="keyword">uint16</span>, <span class="number">2</span>*<span class="built_in">len</span>(cases))</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> cases &#123;</span><br><span class="line">        rc := &amp;cases[i]</span><br><span class="line">        <span class="keyword">switch</span> rc.dir &#123;</span><br><span class="line">        <span class="keyword">case</span> selectDefault:</span><br><span class="line">            sel[i] = scase&#123;kind: caseDefault&#125;</span><br><span class="line">        <span class="keyword">case</span> selectSend:</span><br><span class="line">            sel[i] = scase&#123;kind: caseSend, c: rc.ch, elem: rc.val&#125;</span><br><span class="line">        <span class="keyword">case</span> selectRecv:</span><br><span class="line">            sel[i] = scase&#123;kind: caseRecv, c: rc.ch, elem: rc.val&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> raceenabled || msanenabled &#123;</span><br><span class="line">            selectsetpc(&amp;sel[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> selectgo(&amp;sel[<span class="number">0</span>], &amp;order[<span class="number">0</span>], <span class="built_in">len</span>(cases))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那谁调用的<code>func rselect([]runtimeSelect) (chosen int, recvOK bool)</code>呢？<br>在<code>/refect/value.go</code>中，有一个<code>func Select(cases []SelectCase) (chosen int, recv Value, recvOK bool)</code>的函数，其调用了<code>rselect</code>函数，并将最终Go中select语句的返回值的返回。</p><p>以上这三个函数的调用栈按顺序如下：</p><ul><li><code>func Select(cases []SelectCase) (chosen int, recv Value, recvOK bool)</code></li><li><code>func rselect([]runtimeSelect) (chosen int, recvOK bool)</code></li><li><code>func selectgo(cas0 *scase, order0 *uint16, ncases int) (int, bool)</code></li></ul><p>这仨函数中无论是返回值还是参数都大同小异，可以简单粗暴的认为：函数参数传入的是case语句，返回值返回被选中的case语句。<br>那谁调用了<code>func Select(cases []SelectCase) (chosen int, recv Value, recvOK bool)</code>呢？<br>可以简单的认为是系统了。<br>来个简单的图：<br><img src="/img/select_priciple/select-principle_18.png" alt></p><p>前两个函数<code>Select</code>和<code>rselect</code>都是做了简单的初始化参数，调用下一个函数的操作。select真正的核心功能，是在最后一个函数<code>func selectgo(cas0 *scase, order0 *uint16, ncases int) (int, bool)</code>中实现的。</p><h3 id="selectgo函数做了什么"><a href="#selectgo函数做了什么" class="headerlink" title="selectgo函数做了什么"></a>selectgo函数做了什么</h3><p>打乱传入的case结构体顺序</p><p><img src="/img/select_priciple/select-principle_6.png" alt></p><p>锁住其中的所有的channel<br><img src="/img/select_priciple/select-principle_7.png" alt></p><p>遍历所有的channel，查看其是否可读或者可写</p><p><img src="/img/select_priciple/select-principle_8.png" alt></p><p>如果其中的channel可读或者可写，则解锁所有channel，并返回对应的channel数据</p><p><img src="/img/select_priciple/select-principle_9.png" alt></p><p><img src="/img/select_priciple/select-principle_10.png" alt></p><p>假如没有channel可读或者可写，但是有default语句，则同上:返回default语句对应的scase并解锁所有的channel。</p><p><img src="/img/select_priciple/select-principle_11.png" alt></p><p>假如既没有channel可读或者可写，也没有default语句，则将当前运行的groutine阻塞，并加入到当前所有channel的等待队列中去。</p><p><img src="/img/select_priciple/select-principle_12.png" alt></p><p>然后解锁所有channel，等待被唤醒。<br><img src="/img/select_priciple/select-principle_13.png" alt></p><p>此时如果有个channel可读或者可写ready了，则唤醒，并再次加锁所有channel，<br><img src="/img/select_priciple/select-principle_14.png" alt></p><p>遍历所有channel找到那个对应的channel和G，唤醒G，并将没有成功的G从所有channel的等待队列中移除。</p><p><img src="/img/select_priciple/select-principle_15.png" alt></p><p>如果对应的scase值不为空，则返回需要的值，并解锁所有channel</p><p><img src="/img/select_priciple/select-principle_16.png" alt></p><p>如果对应的scase为空，则循环此过程。</p><h3 id="select和channel之间的关系"><a href="#select和channel之间的关系" class="headerlink" title="select和channel之间的关系"></a>select和channel之间的关系</h3><p>在想想select和channel做了什么事儿，我觉得和多路复用是一回事儿</p><p><img src="/img/select_priciple/select-principle_17.png" alt></p><h4 id="更多精彩内容，请关注我的微信公众号-互联网技术窝-或者加微信共同探讨交流："><a href="#更多精彩内容，请关注我的微信公众号-互联网技术窝-或者加微信共同探讨交流：" class="headerlink" title="更多精彩内容，请关注我的微信公众号 互联网技术窝  或者加微信共同探讨交流："></a>更多精彩内容，请关注我的微信公众号 <code>互联网技术窝</code>  或者加微信共同探讨交流：</h4><p>   <img src="https://i6448038.github.io/img/weichat/qrcode.jpg" alt></p><p>参考文献：</p><ul><li><a href="https://my.oschina.net/renhc/blog/2253937" target="_blank" rel="noopener">https://my.oschina.net/renhc/blog/2253937</a></li><li><a href="https://blog.csdn.net/xd_rbt_/article/details/80287959" target="_blank" rel="noopener">https://blog.csdn.net/xd_rbt_/article/details/80287959</a></li><li><a href="https://blog.csdn.net/qq_34199383/article/details/80303629" target="_blank" rel="noopener">https://blog.csdn.net/qq_34199383/article/details/80303629</a></li><li><a href="https://blog.csdn.net/wangxindong11/article/details/78591308" target="_blank" rel="noopener">https://blog.csdn.net/wangxindong11/article/details/78591308</a></li><li><a href="https://draveness.me/golang-select" target="_blank" rel="noopener">https://draveness.me/golang-select</a></li><li><a href="https://studygolang.com/articles/1807" target="_blank" rel="noopener">https://studygolang.com/articles/1807</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Go 的select语句是一种仅能用于channl发送和接收消息的专用语句，此语句运行期间是阻塞的；当select中没有case语句的时候，会阻塞当前的groutine。所以，有人也会说select是用来阻塞监听goroutine的。&lt;br&gt;还有人说：select是Gola
      
    
    </summary>
    
    
      <category term="Golang" scheme="http://yoursite.com/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>图解Golang的GC算法</title>
    <link href="http://yoursite.com/2019/03/04/golang-garbage-collector/"/>
    <id>http://yoursite.com/2019/03/04/golang-garbage-collector/</id>
    <published>2019-03-04T06:04:26.000Z</published>
    <updated>2019-07-14T06:17:43.154Z</updated>
    
    <content type="html"><![CDATA[<p>虽然Golang的GC自打一开始，就被人所诟病，但是经过这么多年的发展，Golang的GC已经改善了非常多，变得非常优秀了。</p><p>以下是Golang GC算法的里程碑：</p><ul><li>v1.1 STW</li><li>v1.3 Mark STW, Sweep 并行</li><li>v1.5 三色标记法</li><li>v1.8 hybrid write barrier</li></ul><p>经典的GC算法有三种：<code>引用计数(reference counting)</code>、<code>标记-清扫(mark &amp; sweep)</code>、<code>复制收集(Copy and Collection)</code>。</p><p>Golang的GC算法主要是基于<code>标记-清扫(mark and sweep)</code>算法，并在此基础上做了改进。因此，在此主要介绍一下标记-清扫(mark and sweep)算法，关于引用计数(reference counting)和复制收集(copy and collection)可自行百度。</p><h2 id="标记-清扫-Mark-And-Sweep-算法"><a href="#标记-清扫-Mark-And-Sweep-算法" class="headerlink" title="标记-清扫(Mark And Sweep)算法"></a>标记-清扫(Mark And Sweep)算法</h2><p>此算法主要有两个主要的步骤：</p><ul><li>标记(Mark phase)</li><li>清除(Sweep phase)</li></ul><p>第一步，找出不可达的对象，然后做上标记。<br>第二步，回收标记好的对象。</p><p>操作非常简单，但是有一点需要额外注意：mark and sweep算法在执行的时候，需要程序暂停！即<code>stop the world</code>。<br>也就是说，这段时间程序会卡在哪儿。故中文翻译成<code>卡顿</code>。</p><p>我们来看一下图解：</p><p>开始标记，程序暂停。程序和对象的此时关系是这样的：</p><p><img src="/img/gc/mark_sweep_1.png" alt></p><p>然后开始标记，process找出它所有可达的对象，并做上标记。如下图所示：</p><p><img src="/img/gc/mark_sweep_2.png" alt></p><p>标记完了之后，然后开始清除未标记的对象：</p><p><img src="/img/gc/mark_sweep_3.png" alt></p><p>然后垃圾清除了，变成了下图这样。</p><p><img src="/img/gc/mark_sweep_4.png" alt></p><p>最后，停止暂停，让程序继续跑。然后循环重复这个过程，直到process生命周期结束。</p><h3 id="标记-清扫-Mark-And-Sweep-算法存在什么问题？"><a href="#标记-清扫-Mark-And-Sweep-算法存在什么问题？" class="headerlink" title="标记-清扫(Mark And Sweep)算法存在什么问题？"></a>标记-清扫(Mark And Sweep)算法存在什么问题？</h3><p>标记-清扫(Mark And Sweep)算法这种算法虽然非常的简单，但是还存在一些问题：</p><ul><li>STW，stop the world；让程序暂停，程序出现卡顿。</li><li>标记需要扫描整个heap</li><li>清除数据会产生heap碎片</li></ul><p>这里面最重要的问题就是：mark-and-sweep 算法会暂停整个程序。</p><p>Go是如何面对并这个问题的呢？</p><h2 id="三色并发标记法"><a href="#三色并发标记法" class="headerlink" title="三色并发标记法"></a>三色并发标记法</h2><p>我们先来看看Golang的三色标记法的大体流程。</p><p>首先：程序创建的对象都标记为白色。</p><p><img src="/img/gc/mark_sweep_5.png" alt></p><p>gc开始：扫描所有可到达的对象，标记为灰色</p><p><img src="/img/gc/mark_sweep_6.png" alt></p><p>从灰色对象中找到其引用对象标记为灰色，把灰色对象本身标记为黑色</p><p><img src="/img/gc/mark_sweep_7.png" alt></p><p>监视对象中的内存修改，并持续上一步的操作，直到灰色标记的对象不存在</p><p><img src="/img/gc/mark_sweep_8.png" alt></p><p>此时，gc回收白色对象。</p><p><img src="/img/gc/mark_sweep_9.png" alt></p><p>最后，将所有黑色对象变为白色，并重复以上所有过程。</p><p><img src="/img/gc/mark_sweep_10.png" alt></p><p>好了，大体的流程就是这样的，让我们回到刚才的问题：Go是如何解决标记-清除(mark and sweep)算法中的卡顿(stw，stop the world)问题的呢？</p><h2 id="gc和用户逻辑如何并行操作？"><a href="#gc和用户逻辑如何并行操作？" class="headerlink" title="gc和用户逻辑如何并行操作？"></a>gc和用户逻辑如何并行操作？</h2><p>标记-清除(mark and sweep)算法的STW(stop the world)操作，就是runtime把所有的线程全部冻结掉，所有的线程全部冻结意味着用户逻辑是暂停的。这样所有的对象都不会被修改了，这时候去扫描是绝对安全的。</p><p>Go如何减短这个过程呢？标记-清除(mark and sweep)算法包含两部分逻辑：标记和清除。<br>我们知道Golang三色标记法中最后只剩下的黑白两种对象，黑色对象是程序恢复后接着使用的对象，如果不碰触黑色对象，只清除白色的对象，肯定不会影响程序逻辑。所以：<code>清除操作和用户逻辑可以并发。</code></p><p>标记操作和用户逻辑也是并发的，用户逻辑会时常生成对象或者改变对象的引用，那么标记和用户逻辑如何并发呢？</p><h3 id="process新生成对象的时候，GC该如何操作呢？不会乱吗？"><a href="#process新生成对象的时候，GC该如何操作呢？不会乱吗？" class="headerlink" title="process新生成对象的时候，GC该如何操作呢？不会乱吗？"></a>process新生成对象的时候，GC该如何操作呢？不会乱吗？</h3><p>我们看如下图，在此状态下：process程序又新生成了一个对象，我们设想会变成这样：</p><p><img src="/img/gc/mark_sweep_11.png" alt></p><p>但是这样显然是不对的，因为按照三色标记法的步骤，这样新生成的对象A最后会被清除掉，这样会影响程序逻辑。</p><p>Golang为了解决这个问题，引入了<code>写屏障</code>这个机制。<br>写屏障：该屏障之前的写操作和之后的写操作相比，先被系统其它组件感知。<br>通俗的讲：就是在gc跑的过程中，可以监控对象的内存修改，并对对象进行重新标记。(实际上也是超短暂的stw，然后对对象进行标记)</p><p>在上述情况中，<code>新生成的对象，一律都标位灰色！</code><br>即下图：</p><p><img src="/img/gc/mark_sweep_12.png" alt></p><h3 id="那么，灰色或者黑色对象的引用改为白色对象的时候，Golang是该如何操作的？"><a href="#那么，灰色或者黑色对象的引用改为白色对象的时候，Golang是该如何操作的？" class="headerlink" title="那么，灰色或者黑色对象的引用改为白色对象的时候，Golang是该如何操作的？"></a>那么，灰色或者黑色对象的引用改为白色对象的时候，Golang是该如何操作的？</h3><p>看如下图，一个黑色对象引用了曾经标记的白色对象。</p><p><img src="/img/gc/mark_sweep_13.png" alt></p><p>这时候，写屏障机制被触发，向GC发送信号，GC重新扫描对象并标位灰色。</p><p><img src="/img/gc/mark_sweep_14.png" alt></p><p>因此，gc一旦开始，无论是创建对象还是对象的引用改变，都会先变为灰色。</p><p>参考文献：<br><a href="https://making.pusher.com/golangs-real-time-gc-in-theory-and-practice/" target="_blank" rel="noopener">Golang’s Real-time GC in Theory and Practice</a><br><a href="https://www.youtube.com/watch?v=n59VtiRx34s&t=1151" target="_blank" rel="noopener">Golang’s realtime garbage collector</a><br><a href="https://mp.weixin.qq.com/s/Wh7A6czDIRofxveY_bEDNQ" target="_blank" rel="noopener">Golang 垃圾回收剖析</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;虽然Golang的GC自打一开始，就被人所诟病，但是经过这么多年的发展，Golang的GC已经改善了非常多，变得非常优秀了。&lt;/p&gt;
&lt;p&gt;以下是Golang GC算法的里程碑：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;v1.1 STW&lt;/li&gt;
&lt;li&gt;v1.3 Mark STW, S
      
    
    </summary>
    
    
      <category term="golang" scheme="http://yoursite.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>秒懂InnoDB的锁</title>
    <link href="http://yoursite.com/2019/02/23/mysql-lock/"/>
    <id>http://yoursite.com/2019/02/23/mysql-lock/</id>
    <published>2019-02-23T07:19:39.000Z</published>
    <updated>2019-10-26T12:18:32.113Z</updated>
    
    <content type="html"><![CDATA[<p>今天我们来聊聊MySQL中InnoDB存储引擎的锁。</p><p>锁是数据库系统系统区别于文件系统的一个关键特性。</p><h1 id="lock和-latch"><a href="#lock和-latch" class="headerlink" title="lock和 latch"></a>lock和 latch</h1><h2 id="latch"><a href="#latch" class="headerlink" title="latch"></a>latch</h2><p><code>latch</code>在MySQL中是用来保证并发多线程操作操作临界资源的<code>锁</code>，锁定的对象线程，是和咱们使用的Java等传统语言中的锁意义相近，而且没有死锁检测的机制。</p><h2 id="lock"><a href="#lock" class="headerlink" title="lock"></a>lock</h2><p><code>lock</code>是MySQL中在事务中使用的<code>锁</code>，锁定的对象是事务，来锁定数据库中表、页、行；通常只有在事务commit或者rollback后进行释放。lock是有死锁机制的，当出现死锁时，lock有死锁机制来解决死锁问题：超时时间(参数<code>innodb_lock_wait_timeout</code>)、<code>wait-for graph</code>。</p><p>我们通常讲的MySQL的“锁”，一般就是说的lock。</p><p>以下就是InnoDB中“锁”的大分类：</p><p><img src="/img/mysql_lock/lock_latch.png" alt></p><h1 id="lock的种类"><a href="#lock的种类" class="headerlink" title="lock的种类"></a>lock的种类</h1><p>MySQL Lock大体上可以分为：表锁、行锁、意向锁三种。</p><p><img src="/img/mysql_lock/Locks.png" alt></p><h2 id="共享-排他锁"><a href="#共享-排他锁" class="headerlink" title="共享/排他锁"></a>共享/排他锁</h2><p>行锁分为：<code>S Lock</code>和<code>X Lock</code>。<code>S Lock</code> ：读锁；<code>X Lock</code>：写锁。<br>两锁之间的兼容性如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">       X         S</span><br><span class="line">X     不兼容     不兼容</span><br><span class="line">S     不兼容     兼容</span><br></pre></td></tr></table></figure><p>简单总结为：<code>读锁可以读，读锁不可写；写锁不可读也tm不可写。</code></p><h2 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h2><p>InnoDB支持多粒度的锁，即：允许表锁和行锁同时存在。<br>但是，假如表锁覆盖了行锁的数据，所以表锁和行锁也会产生冲突。如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">trx1 BEGI</span><br><span class="line"></span><br><span class="line">trx1 给 T1 加X锁修改数据。</span><br><span class="line"></span><br><span class="line">trx2 BEGIN</span><br><span class="line"></span><br><span class="line">trx2 给 T1 加表锁修改表结构</span><br></pre></td></tr></table></figure><p>这样，表锁和行锁之间就产生了冲突，为了解决这种表锁和行锁共存的问题，就产生了<code>意向锁</code>这个东西。<br>意向锁：从字面意思也很好理解，就是提前表明一个“意向”。</p><p>意向锁分为：</p><ul><li><code>意向共享锁</code>。它预示着，事务正在或者有意向对表中的”某些行”加S锁。<code>select xxxx lock in share mode</code>，要设置<code>IS</code>锁。</li><li><code>意向排他锁</code>。它预示着，事务正在或者有意向表中的“某些行”加X锁。<code>select xxx for update</code>，要设置<code>IX</code>锁。</li></ul><p>但意向锁仅仅是表明意向，它其实非常弱，意向锁之间可以相互并行，并不是排斥的：<br>意向锁之间的兼容性问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">      IS     IX</span><br><span class="line"></span><br><span class="line">IS   兼容    兼容</span><br><span class="line"></span><br><span class="line">IX   兼容    兼容</span><br></pre></td></tr></table></figure><p>但是，意向锁可以和表锁互斥。(注意：文中 S 和 X均为表锁)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">        S                X</span><br><span class="line"></span><br><span class="line">IS     兼容           互斥不兼容</span><br><span class="line"></span><br><span class="line">IX    互斥不兼容        互斥不兼容</span><br></pre></td></tr></table></figure><p>于是，上述现象就变为了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">trx1 BEGIN</span><br><span class="line"></span><br><span class="line">trx1 给 T1 先加IX ，然后在某一行记录加X锁。</span><br><span class="line"></span><br><span class="line">trx2 BEGIN</span><br><span class="line"></span><br><span class="line">trx2 给 T1 加表锁X（事务被阻塞，等待加锁成功)</span><br><span class="line"></span><br><span class="line">trx2 修改表结构</span><br></pre></td></tr></table></figure><p>也许有人会问：“意向锁存在的意义是什么呢？没有意向锁，行锁和表锁照样可以共存啊？”<br>试问如何共存？<br>“查看表中某一行存在X锁”<br>“如何查看呢？”<br>唯有全表扫描…<br>意向锁的存在就是解决了“全表扫描”的性能问题，所以，意向锁一定是“表级”锁，告诉整张表XXX行存在X锁。此时假如进行表操作就会被阻塞。</p><h2 id="主键自增锁"><a href="#主键自增锁" class="headerlink" title="主键自增锁"></a>主键自增锁</h2><p>自增锁(<code>auto-inc Locks</code>)是一种特殊的表级锁，专门针对事务插入<code>AUTO_INCREMENT</code>类型的列，往往就是主键列。可以保证主键的值自增是“原子操作”，不会出现一致性、唯一性问题。</p><h1 id="行锁的具体分类"><a href="#行锁的具体分类" class="headerlink" title="行锁的具体分类"></a>行锁的具体分类</h1><p><img src="/img/mysql_lock/arithmetic.png" alt></p><p>InnoDB存储引擎有以上3种行锁算法。以上3种，都是实现在索引上的。</p><h2 id="记录锁-Record-Lock"><a href="#记录锁-Record-Lock" class="headerlink" title="记录锁(Record Lock)"></a>记录锁(Record Lock)</h2><p>记录锁(Record Lock)总是会去锁住索引记录。<br>假如没有任何一个索引，那么InnoDB会锁住隐形创建的那个主键。</p><p>注意：这里锁的是索引，不一定只是主键索引哦，还可能是二级普通索引。</p><h2 id="间隙锁-Gap-Lock"><a href="#间隙锁-Gap-Lock" class="headerlink" title="间隙锁(Gap Lock)"></a>间隙锁(Gap Lock)</h2><p>顾名思义，它会封锁索引记录中的“缝隙”，让制其他事务在“缝隙”中插入数据。<br>它锁定的是一个不包含索引本身的范围。</p><p>例如以下索引数据：<br><img src="/img/mysql_lock/gap_lock.png" alt></p><p><code>间隙锁(Gap Lock)</code>可以锁的将是以下范围</p><p><img src="/img/mysql_lock/gap_lock_1.png" alt></p><p>具体的范围还要根据查询条件不同而定。<br>间隙锁开启的事务隔离级别是 <code>Repeatable Read</code>，如果把数据库事务级别降为<code>Read Committed</code>(默认是 <code>Repeatable Read</code>)，间隙锁则会自动失效。</p><h2 id="临键锁-Next-Key-Lock"><a href="#临键锁-Next-Key-Lock" class="headerlink" title="临键锁(Next-Key Lock)"></a>临键锁(Next-Key Lock)</h2><p><code>Next-Key Lock</code>可以说是记录锁(<code>Record Lock</code>)和间隙锁（<code>Gap Lock</code>）的组合，既封锁了”缝隙”，又封锁了索引本身。</p><p>还是上面的索引数据：<br><img src="/img/mysql_lock/gap_lock.png" alt></p><p><code>临键锁(Next-Key Lock)</code>锁住的范围将是:</p><p><img src="/img/mysql_lock/gap_lock_2.png" alt></p><p><code>Next-key Lock</code>在索引具有唯一性的时候，例如主键索引的数据，将会降级为<code>记录锁(Read Lock)</code>，以增加并发性。<br>例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">        T1                                     T2</span><br><span class="line">        BEGIN;                   |            </span><br><span class="line">   select * From T               |           </span><br><span class="line">   where id = 5 for update       |</span><br><span class="line">---------------------------------------------------------------</span><br><span class="line">                                 |            BEGIN; </span><br><span class="line">                                 |          Insert into t (4, xx);</span><br><span class="line">---------------------------------------------------------------              </span><br><span class="line">                                 |          COMMIT</span><br><span class="line">                                 |             </span><br><span class="line">----------------------------------------------------------------</span><br><span class="line">     COMMIT                      |                            </span><br><span class="line">                                 |</span><br><span class="line">                                 |</span><br><span class="line">-----------------------------------------------------------------</span><br></pre></td></tr></table></figure><p>以上情况，就会把<code>Next-key Lock</code>降级为<code>记录锁(Read Lock)</code></p><h1 id="再谈不可重复读-No-Reaptable-Read-和幻读-Phantom-Problem"><a href="#再谈不可重复读-No-Reaptable-Read-和幻读-Phantom-Problem" class="headerlink" title="再谈不可重复读(No Reaptable Read)和幻读(Phantom Problem)"></a>再谈不可重复读(<code>No Reaptable Read</code>)和幻读(<code>Phantom Problem</code>)</h1><p>有些很权威的书中认为这俩是同一个概念，例如:&lt;&lt;MySQL技术内幕 InnoDB存储引擎&gt;&gt;。<br>但是就目前网络上的众多总结和个人看法，认为区别如下：</p><p><code>不可重复读</code>：修改。在同一个事务中，主要是说多次读取一条记录, 发现该记录中某些列值被修改过。<br><code>幻读</code>:增加或者删除。在同一个事务中，同一条完全相同的查询语句返回的结果集行数不同。</p><p>参考：<a href="https://stackoverflow.com/questions/11043712/what-is-the-difference-between-non-repeatable-read-and-phantom-read" target="_blank" rel="noopener">https://stackoverflow.com/questions/11043712/what-is-the-difference-between-non-repeatable-read-and-phantom-read</a></p><p>认真的说，<code>多版本并发控制 MVCC</code>（读）和 <code>临键锁 Next-Key Lock</code>（写）共同解决了<code>幻读</code>问题。</p><p>关于MVCC的原理，就是每份数据会有快照，事务中读取数据(简单的<code>select xxx from</code>，<code>select xx from xx for update</code>或者<code>select xx from xxx in share mode</code>不行)的时候，如果数据被锁住了，就读以前留下的快照数据。在此不过多赘述了。</p><p>以下为多版本并发控制原理图<br><img src="/img/mysql_lock/mvcc.png" alt></p><p><code>MVCC</code>只在<code>Read Committed</code>和<code>Repeatable Read</code>下会开启。但是在这两种隔离级别下对于快照指定的数据定义不同。</p><p>在<code>Read Committed</code>下，<code>MVCC</code>读取的是被锁定数据的最新的一份数据。<br>在<code>Repeatable Read</code>下，<code>MVCC</code>读取的是事务刚开始时候的数据。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天我们来聊聊MySQL中InnoDB存储引擎的锁。&lt;/p&gt;
&lt;p&gt;锁是数据库系统系统区别于文件系统的一个关键特性。&lt;/p&gt;
&lt;h1 id=&quot;lock和-latch&quot;&gt;&lt;a href=&quot;#lock和-latch&quot; class=&quot;headerlink&quot; title=&quot;lock
      
    
    </summary>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL的SQL性能优化总结</title>
    <link href="http://yoursite.com/2019/02/16/mysql-performance-optimize/"/>
    <id>http://yoursite.com/2019/02/16/mysql-performance-optimize/</id>
    <published>2019-02-16T05:06:43.000Z</published>
    <updated>2019-07-14T06:17:43.130Z</updated>
    
    <content type="html"><![CDATA[<p>很多时候，我们的程序出现的“性能问题”，其实是我们自己写的那”坨”代码的问题，是自己Coding的问题，是Mysql的DML语句使用的问题。<br>以下是我总结的关于MySQL DML语句的使用中需要注意的点。</p><h2 id="对于select-要时刻保持谨慎的态度"><a href="#对于select-要时刻保持谨慎的态度" class="headerlink" title="对于select *要时刻保持谨慎的态度"></a>对于<code>select *</code>要时刻保持谨慎的态度</h2><p>绝大多数情况，是不需要<code>select *</code>的。一旦使用了这种语句，便会让优化器无法完成索引覆盖扫描这类优化，而且还会增加额外的I/O、内存和CPU的消耗。<br>当然，使用<code>select *</code>也并不是全是坏处，合理的使用<code>select *</code>可以简化开发，提高相同代码的复用性。</p><h2 id="是否扫描的太多额外的记录"><a href="#是否扫描的太多额外的记录" class="headerlink" title="是否扫描的太多额外的记录"></a>是否扫描的太多额外的记录</h2><p>有时候会发现某些查询可能需要读取几千行数据，但是仅返回几条或者很少的结果，可以使用以下方式去优化：</p><ul><li>看看能否改表结构。例如使用汇总表</li><li>看看获取数据结果的方式是否最优，获取路劲是否已经是最短。</li><li>使用覆盖索引，把所有需要的列都放到索引中，以减少返回表中对应行中取数据的步骤。</li></ul><h2 id="切分某些SQL语句"><a href="#切分某些SQL语句" class="headerlink" title="切分某些SQL语句"></a>切分某些SQL语句</h2><p>传统的互联网系统中，强调网络连接尽量少，数据层尽可能在一次连接中完成尽可能多的工作，防止建立多次链接，但是这种想法对于MySQL并不适用，MySQL从设计上让连接和断开都很轻量，在一般服务器上可以支持每秒超过10万的查询。</p><p>所以对于有些场景下，可以将一个大的查询“分而治之”，切分成小查询，然后再组合起来。例如以下情况：</p><ul><li>对于全量数据查询变成分页。假如一张表中有数千万条数据，一次select all，肯定是不行的。可以换成一次取一部分，把一次的压力分摊。</li><li>删除大量旧数据的时候，不要一个大的语句一次性清完，推荐<code>一次删一万条</code>。如果用一个大的语句一次性完成的话，可能需要一次锁住大量数据，占满大量日志事务，让Mysql停在那儿了，为避免这种情况发生，最好一次性删除一万条左右的数据，然后每次删完暂停一会儿再操作，将服务器上的一次性压力分散。</li></ul><p>注意：虽然Mysql建立连接十分轻量，但是这不意味着可以逐条循环中查询然后再拼接，这样效率依然是非常慢，而且通常是工作中sql优化的点。</p><h2 id="慎用join操作"><a href="#慎用join操作" class="headerlink" title="慎用join操作"></a>慎用<code>join</code>操作</h2><p>这算是一条禁忌吧，很多公司的互联网产品都杜绝join操作，换成先从一张表中先取出数据id，再从另外一张表中使用<code>where in</code>查询的两次单表查询操作。主要是以下几点原因：</p><ul><li>让应用的缓存(redis、memcache等)更高效。例如在第一张表中查询出部分id了，如果命中了缓存，就可以省去一条where in语句了。</li><li>更容易应对业务的发展，方便对数据库进行拆分，更容易做到高性能和高扩展。</li><li>对where in中的id进行升序排序后，查询效率比join的随机关联更高效</li><li>减少多余的查询。在应用层中两次查询，意味着对某条记录应用只需要查询一次，而使用join可能需要重复的扫描访问一部分数据。</li><li>单张表查询可以减少锁的竞争。</li></ul><p>假如非用不可，可以采用以下方式来优化：</p><ul><li>确保<code>ON</code>或者<code>using</code>子句中的列上有索引</li><li>确保任何的<code>group by</code>和<code>order by</code>中的表达式只涉及到一个表中的列。</li></ul><h2 id="在性能要求比较高的场景中，杜绝查询中使用临时表"><a href="#在性能要求比较高的场景中，杜绝查询中使用临时表" class="headerlink" title="在性能要求比较高的场景中，杜绝查询中使用临时表"></a>在性能要求比较高的场景中，杜绝查询中使用<code>临时表</code></h2><p>MySQL的临时表示没有任何索引的，使用临时表一般都意味着性能比较低,因此在对性能要求比较高的场景中，最好不要使用带有临时表的操作：</p><ul><li>未带索引的字段上的<code>group by</code>操作。</li><li><code>UNION</code>查询。</li><li>查询语句中的子查询。</li><li>部分<code>order by</code>操作，例如<code>distinct</code>函数和<code>order by</code>一起使用且<code>distinct</code>和<code>order by</code>同一个字段。再例如某些情况下<code>group by</code>和<code>order by</code>字段不同。</li></ul><p>具体是否用到临时表，可以通过<code>explain</code>来查看，查看<code>Extra</code>列的结果，如果出现<code>Using temporary</code>则需要注意。</p><h2 id="count-函数优化"><a href="#count-函数优化" class="headerlink" title="count()函数优化"></a><code>count()</code>函数优化</h2><p><code>count()</code>函数有一点需要特别注意：它是不统计值为NULL的字段的！所以：不能指定查询结果的某一列，来统计结果行数。即<code>count(xx column)</code> 不太好。</p><p>如果想要统计结果集，就使用<code>count(*)</code>，性能也会很好。</p><h2 id="尽量不使用子查询"><a href="#尽量不使用子查询" class="headerlink" title="尽量不使用子查询"></a>尽量不使用子查询</h2><p>尽量别使用子查询，尽可能的使用关联来代替</p><h2 id="优化分页limit"><a href="#优化分页limit" class="headerlink" title="优化分页limit"></a>优化分页<code>limit</code></h2><p>通常我们在分页的时候，通常使用的是<code>limit 50, 10</code>这种语句。数据少还不错，但是当数据偏移量非常大的时候，性能就会出现问题，例如<code>select xx,xxx from test_table limit 100000020, 20</code>。扫描了100000020条数据，才返回20条数据。这个时候我们可以用一下两种方式来优化：</p><h3 id="利用between-and和主键索引"><a href="#利用between-and和主键索引" class="headerlink" title="利用between and和主键索引"></a>利用<code>between and</code>和主键索引</h3><p>利用主键自增id，我们如果知道了分页的上边界，以上查询可以改写为：<br><code>select xxx, xxx from test_table where id between xxxxx and xxxx</code>。</p><h3 id="利用自增主键索引、order-by加limit，不使用offset"><a href="#利用自增主键索引、order-by加limit，不使用offset" class="headerlink" title="利用自增主键索引、order by加limit，不使用offset"></a>利用自增主键索引、<code>order by</code>加<code>limit</code>，不使用offset</h3><p> <code>limit</code>和<code>offset</code>的问题，其实就是<code>offset</code>的问题，它会导致MySQL扫描大量不需要的行然后再抛弃掉。如果使用某个标签记录上一次所取数据的位置，那么下次就可以直接从书签位置开始扫描，这样就可以避免使用<code>offset</code>。</p><p> 例如以上查询可以改为:</p><p> 第一组数据：``select xxx, xxxx from test_table order by id desc limit 20;</p><p> 这样就拿到了本次数据和下次数据的分解id值，则下一页查询就知道可以：<br><code>select xxx, xxx from test_table where id &lt; &#39;上页id分界值&#39; order by id desc limit 20</code></p><h2 id="熟悉并灵活使用explain"><a href="#熟悉并灵活使用explain" class="headerlink" title="熟悉并灵活使用explain"></a>熟悉并灵活使用<code>explain</code></h2><p>以下是mysql执行查询的整个过程，<code>explain</code>可以查看图中标红部分，</p><p><img src="/img/mysql_performace/mysql_performace.png" alt></p><p><code>explain</code>会展示很多字段和内容，其中的内容往往不好记，使用的时候，可以查看以下图解内容:<br><a href="https://i6448038.github.io/2019/02/07/explain-image" target="_blank" rel="noopener">explain图解</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;很多时候，我们的程序出现的“性能问题”，其实是我们自己写的那”坨”代码的问题，是自己Coding的问题，是Mysql的DML语句使用的问题。&lt;br&gt;以下是我总结的关于MySQL DML语句的使用中需要注意的点。&lt;/p&gt;
&lt;h2 id=&quot;对于select-要时刻保持谨慎的态度
      
    
    </summary>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Mysql执行计划explain图解</title>
    <link href="http://yoursite.com/2019/02/07/explain-image/"/>
    <id>http://yoursite.com/2019/02/07/explain-image/</id>
    <published>2019-02-07T10:14:35.000Z</published>
    <updated>2020-01-07T07:10:17.289Z</updated>
    
    <content type="html"><![CDATA[<p>在日常工作中，我们的项目如果发现查询很慢了，往往会去查看MySQL的慢查询日志，找到对应的SQL；<br>找到这个SQL并不就此完事儿了，还会对当前SQL进行优化；使用MySQL的explain命令，将会事半功倍！</p><p>但是就目前来看，explain指令的解析都是文字，大量的文字!一点不形象、不直观、使用的时候查起来也非常麻烦，因此，我做了一张表格，供大家参考和查阅。</p><p>以下是Mysql执行计划的图解。在使用explain的时候可以参考使用。</p><p>PS：图片若小，可保存放大使用。</p><p><img src="/img/explain/explain.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在日常工作中，我们的项目如果发现查询很慢了，往往会去查看MySQL的慢查询日志，找到对应的SQL；&lt;br&gt;找到这个SQL并不就此完事儿了，还会对当前SQL进行优化；使用MySQL的explain命令，将会事半功倍！&lt;/p&gt;
&lt;p&gt;但是就目前来看，explain指令的解析都是
      
    
    </summary>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Golang非CSP并发模型外的其他并行方法总结</title>
    <link href="http://yoursite.com/2018/12/18/Golang-no-csp/"/>
    <id>http://yoursite.com/2018/12/18/Golang-no-csp/</id>
    <published>2018-12-18T14:36:18.000Z</published>
    <updated>2019-07-14T06:17:43.130Z</updated>
    
    <content type="html"><![CDATA[<p>Golang最为让人熟知的并发模型当属CSP并发模型，也就是由goroutine和channel构成的<a href="https://i6448038.github.io/2017/12/04/golang-concurrency-principle/" target="_blank" rel="noopener">GMP并发模型</a>，具体内容不在赘述了，可以翻回之前的文章查看。在这里，要讲讲Golang的其他并发方式。</p><p>Golang不仅可以使用CSP并发模式，还可以使用传统的共享数据的并发模式。</p><h1 id="临界区-critical-section"><a href="#临界区-critical-section" class="headerlink" title="临界区(critical section)"></a>临界区(critical section)</h1><p>这是传统语言比较常用的的方式，即加锁。加锁使其线程同步，每次只允许一个goroutine进入某个代码块，此代码块区域称之为”<em>临界区(critical section)</em>”。</p><p>Golang为<em>临界区(critical section)</em>提供的是互斥锁的包和条件变量的包。</p><h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><p>就是通常使用的锁，用来让线程串行用的。Golang提供了互斥锁<code>sync.Mutex</code>和读写互斥锁 <code>sync.RWMutex</code>，用法极其简单：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s sync.Mutex</span><br><span class="line">    </span><br><span class="line">s.Lock()</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 这里的代码就是串行了，吼吼吼。。。</span></span><br><span class="line">    </span><br><span class="line">s.Unlock()</span><br></pre></td></tr></table></figure><p>Lock和Unlock</p><h3 id="sync-Mutex和sync-RWMutex的区别"><a href="#sync-Mutex和sync-RWMutex的区别" class="headerlink" title="sync.Mutex和sync.RWMutex的区别"></a><code>sync.Mutex</code>和<code>sync.RWMutex</code>的区别</h3><p>没啥大的区别，只不过<code>sync.RWMutex</code>更加细腻，可以将“读操作”和“写操作”区别对待。<br><code>sync.RWMutex</code>中的Lock和unLock针对写操作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s sync.RWMutex</span><br><span class="line"></span><br><span class="line">s.Lock()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上写锁了，吼吼</span></span><br><span class="line"></span><br><span class="line">s.Unlock()</span><br></pre></td></tr></table></figure><p><code>sync.RWMutex</code>中的RLock和RUnLock针对读操作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s sync.RWMutex</span><br><span class="line"></span><br><span class="line">s.RLock()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上读锁了，吼吼..</span></span><br><span class="line"></span><br><span class="line">s.RUnlock()</span><br></pre></td></tr></table></figure><p>读写锁有以下规则：</p><ul><li>写锁被锁定，（再试图进行）读锁和写锁都阻塞</li><li>读锁被锁定，（再试图进行）写锁阻塞，（再试图进行）读锁不阻塞</li></ul><p>即：多个写操作不能同时进行，写操作和读操作也不能同时进行，多个读操作可以同时进行</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><ul><li>不要重复锁定互斥锁；因为代码写起来麻烦，容易出错，万一死锁(deadlock)了就废了。Go语言运行时系统自己抛出的panic都属于致命错误，都是无法恢复的，调用<code>recover</code>函数对它们起不到任何作用。一旦产生死锁，程序必然崩溃。</li><li>锁定和解锁一定要成对出现，如果怕忘记解锁，最好是使用<code>defer</code>语句来解锁；但是，一定不要对未锁定的或者已经锁定的互斥锁解锁，因为会触发<code>panic</code>，而且此<code>panic</code>和死锁一样，属于致命错误，程序肯定崩溃</li><li><code>sync.Mutex</code>是个结构体，尽量不要其当做参数，在多个函数直接传播。因为没啥意义，Golang的参数都是副本，多个副本之间都是相互独立的。</li></ul><h2 id="条件变量Cond"><a href="#条件变量Cond" class="headerlink" title="条件变量Cond"></a>条件变量Cond</h2><p>互斥锁是用来锁住资源，“创造”临界区的。而条件变量Cond可以认为是用来自行调度线程(在此即为groutine)的，当某个状态时，阻塞等待，当状态改变时，唤醒。</p><p>Cond的使用，离不开互斥锁，即离不开<code>sync.Mutex</code>和<code>sync.RWMutex</code>。<br>Cond初始化都需要有个互斥锁。（ps:哪怕初始化不需要，就应用场景而言，也得需要个互斥锁）</p><p><code>Cond</code>提供Wait、Signal、Broadcast 三种方法。<br>Wait表示线程(groutine)阻塞等待；<br>Signal表示唤醒等待的groutine；<br>Broadcast表示唤醒等待的所有groutine;</p><p>初始化：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cond := sync.NewCond(&amp;sync.Mutex&#123;&#125;)</span><br></pre></td></tr></table></figure><p>在其中一个groutine中:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cond.L.Lock()</span><br><span class="line"><span class="keyword">for</span> status == <span class="number">0</span> &#123;</span><br><span class="line">     cond.Wait()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//状态改变，goroutine被唤醒后，干点啥。。。</span></span><br><span class="line">cond.L.Unlock()</span><br></pre></td></tr></table></figure><p>以上算是模板</p><p>在另外一个groutine中:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cond.L.Lock()</span><br><span class="line">status = <span class="number">1</span></span><br><span class="line">cond.Signal() <span class="comment">// 或者使用cond.Broadcast()来唤醒以上groutine中沉睡的groutine</span></span><br><span class="line">cond.L.Unlock()</span><br></pre></td></tr></table></figure><h1 id="原子操作-atomicity"><a href="#原子操作-atomicity" class="headerlink" title="原子操作(atomicity)"></a>原子操作(atomicity)</h1><p>原子操作是硬件芯片级别的支持，所以可以保证绝对的线程安全。而且执行效率比其他方式要高出好几个数量级。</p><p>Go语言的原子操作当然也是基于CPU和操作系统的，Go语言提供的原子操作的包是<code>sync/atomic</code>，此包提供了加(Add)、CAS(交换并比较 compare and swap)、成对出现的存储(store)和加载(load)以及交换(swap)。</p><p>此包提供的大多数函数针对的数据类型也非常的单一：只有整型！使用方式十分的简单，看着函数直接调用就好。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int32</span></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">a = atomic.AddInt32(&amp;a, <span class="number">2</span>) <span class="comment">//此处是原子操作，就这么简单，吼吼</span></span><br></pre></td></tr></table></figure><p>在此特别强调一下CAS，CAS对应的函数前缀是“CompareAndSwap”，含义和用法正如英文翻译：比较并交换。在进行CAS操作的时候，函数会先判断被操作变量的当前值是否与我们预期的旧值相等，如果相等，它就把新值赋给该变量，并返回true，反之，就忽略此操作，并返回false。</p><p>可能是Golang提供的原子操作的数据类型实在是有限，Go又补充了一个结构体<code>atomic.Value</code>，此结构体相当于一个小容器，可以提供原子操作的存储<code>store</code>和提取<code>load</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> atomicVal atomic.Value</span><br><span class="line">str := <span class="string">"hello"</span></span><br><span class="line"></span><br><span class="line">atomicVal.Store(str) <span class="comment">//此处是原子操作哦</span></span><br><span class="line"></span><br><span class="line">newStr := atomicVal.Load() <span class="comment">//此处是原子操作哦</span></span><br></pre></td></tr></table></figure><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>为了能更好的调度goroutine，Go提供了<code>sync.WaitGroup</code>、<code>sync.Once</code>还有<code>context</code></p><h2 id="sync-WaitGroup"><a href="#sync-WaitGroup" class="headerlink" title="sync.WaitGroup"></a><code>sync.WaitGroup</code></h2><p><code>sync.WaitGroup</code>的作用就是在多goroutine并发程序中，让主goroutine等待所有goroutine执行结束。（直接查看代码注释）<br><code>sync.WaitGroup</code>提供了三个函数<code>Add</code>、<code>Done</code>和<code>Wait</code>三者用法如下：</p><ul><li>Add 写在主goroutine中，参数为将要运行的goroutine的数量</li><li>Done 写在各个非主goroutine中，表示运行结束</li><li>Wait 写在主goroutine中，block主goroutine，等待所有其他goroutine运行结束</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wait sync.WaitGroup</span><br><span class="line"></span><br><span class="line">    wait.Add(<span class="number">2</span>) <span class="comment">//必须是运行的goroutine的数量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">//TODO 一顿小操作</span></span><br><span class="line">        <span class="keyword">defer</span> wait.Done() <span class="comment">// done函数用在goroutine中，表示goroutine操作结束</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">//TODO 一顿小操作</span></span><br><span class="line">        <span class="keyword">defer</span> wait.Done() <span class="comment">// done函数用在goroutine中，表示goroutine操作结束</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    wait.Wait() <span class="comment">// block住了，直到所有goroutine都结束</span></span><br></pre></td></tr></table></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p><code>sync.WaitGroup</code>中有一个计数器，记录的是需要等待的goroutine的数量，默认值是0，可以通过Add方法来增加或者减少值，但是切记，千万不能让计数器的值小于零，会触发panic！</p><p><code>sync.WaitGroup</code>调用Wait方法的时候，<code>sync.WaitGroup</code>中计数器的值一定要为0。因此Add中的值一定要等于非主goroutine的数量！<br>且不要把Add和Wait方法放到不同的goroutine中执行！</p><h2 id="sync-Once"><a href="#sync-Once" class="headerlink" title="sync.Once"></a><code>sync.Once</code></h2><p>真真正正的只执行一次。</p><p><code>sync.Once</code>只要一个方法：<code>Do</code>，里面就一个参数:<code>func</code>。多说无益，复制下面代码，猜猜执行结果就知道了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> once sync.Once</span><br><span class="line">    onceBody := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"Only once"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            once.Do(onceBody)</span><br><span class="line">            done &lt;- <span class="literal">true</span></span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        &lt;-done</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Only once</span><br></pre></td></tr></table></figure><p>没错，只有一行。真只执行了一次。</p><h2 id="context"><a href="#context" class="headerlink" title="context"></a>context</h2><p>context可以用来实现一对多的goroutine协作。这个包的应用场景主要是在API中。字面意思也很直接，上下文。当一个请求来时，会产生一个goroutine，但是这个goroutine往往要衍生出许多额外的goroutine去处理操作，例如链接database、请求rpc请求。。等等，这些衍生的goroutine和主goroutine有很多公用数据的，例如同一个请求生命周期、用户认证信息、token等，当这个请求超时或者被取消的时候，这里所有的goroutine都应该结束。context就可以帮助我们达到这个效果。</p><p>很显然，主goroutine和衍生的所有子goroutine之间形成了一颗树结构。我们的context可以从根节点遍布整棵树，当然，是线程安全的。</p><p>线程之间的基本是这样的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DoSomething</span><span class="params">(ctx context.Context, arg Arg)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// ... use ctx ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有两个根context:background和todo；这两个根都是contenxt空的，没有值的。两者也没啥太本质的区别，Background是最常用的，作为Context这个树结构的最顶层的Context，它不能被取消。当不知道用啥context的时候就可以用TODO。</p><p>根生成子节点有以下方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生成可撤销的Context (手动撤销)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span> <span class="params">(ctx Context, cancel CancelFunc)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">//生成可定时撤销的<span class="title">Context</span> <span class="params">(定时撤销)</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">WithDeadline</span><span class="params">(parent Context, deadline time.Time)</span> <span class="params">(Context, CancelFunc)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">//也是生成可定时撤销的<span class="title">Context</span> <span class="params">(定时撤销)</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">WithTimeout</span><span class="params">(parent Context, timeout time.Duration)</span> <span class="params">(Context, CancelFunc)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">//不可撤销的<span class="title">Context</span>,可以存一个<span class="title">kv</span>的值</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">WithValue</span><span class="params">(parent Context, key, val <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Context</span></span></span><br></pre></td></tr></table></figure><h3 id="可撤销的Context"><a href="#可撤销的Context" class="headerlink" title="可撤销的Context"></a>可撤销的Context</h3><p>以下是每个方法的调用方式(全都来自godoc，可粘贴复用)：<br>可撤销的<code>func WithCancel(parent Context) (ctx Context, cancel CancelFunc)</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">gen := <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span> &lt;-<span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    dst := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    n := <span class="number">1</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> &lt;-ctx.Done(): <span class="comment">//只有撤销函数被调用后，才会触发</span></span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="keyword">case</span> dst &lt;- n:</span><br><span class="line">                n++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> dst</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line"><span class="keyword">defer</span> cancel()  <span class="comment">//调用返回的cancel方法来让 context声明周期结束</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> n := <span class="keyword">range</span> gen(ctx) &#123;</span><br><span class="line">    fmt.Println(n)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">5</span> &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要想结束所有线程，就调用<code>ctx, cancel := context.WithCancel(context.Background())</code>函数返回的cancel函数即可，当撤销函数被调用之后，对应的Context值会先关闭它内部的接收通道，也就是它的Done方法返回的通道。</p><p><code>WithDeadline</code>和<code>WithTimeout</code>用法基本类似，而且WithTimeout函数内部调用了WithDeadline函数。两者唯一区别是WithTimeout表示从现在开始xxx超时，而WithDeadline的时间可以是之前的时间：意思是说WithTimeout表示从现在开始， xxx时间后超时。而WithDeadline表示xx时间点，结束！这个时间点可以是昨天，时间点不收任何限制。</p><p>以下是godoc给出的列子：</p><p><code>WithDeadline</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"context"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    d := time.Now().Add(<span class="number">50</span> * time.Millisecond)</span><br><span class="line">    ctx, cancel := context.WithDeadline(context.Background(), d)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Even though ctx will be expired, it is good practice to call its</span></span><br><span class="line">    <span class="comment">// cancelation function in any case. Failure to do so may keep the</span></span><br><span class="line">    <span class="comment">// context and its parent alive longer than necessary.</span></span><br><span class="line">    <span class="keyword">defer</span> cancel() <span class="comment">//时间超时会自动调用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(<span class="number">1</span> * time.Second):</span><br><span class="line">        fmt.Println(<span class="string">"overslept"</span>)</span><br><span class="line">    <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">        fmt.Println(ctx.Err())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context deadline exceeded</span><br></pre></td></tr></table></figure><p><code>WithTimeout</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"context"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Pass a context with a timeout to tell a blocking function that it</span></span><br><span class="line">    <span class="comment">// should abandon its work after the timeout elapses.</span></span><br><span class="line">    ctx, cancel := context.WithTimeout(context.Background(), <span class="number">50</span>*time.Millisecond)</span><br><span class="line">    <span class="keyword">defer</span> cancel() <span class="comment">//时间超时会自动调用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(<span class="number">1</span> * time.Second):</span><br><span class="line">        fmt.Println(<span class="string">"overslept"</span>)</span><br><span class="line">    <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">        fmt.Println(ctx.Err()) <span class="comment">// prints "context deadline exceeded"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context deadline exceeded</span><br></pre></td></tr></table></figure><h3 id="不可撤销的context，传递值"><a href="#不可撤销的context，传递值" class="headerlink" title="不可撤销的context，传递值"></a>不可撤销的context，传递值</h3><p><code>WithValue</code>可以用来在传递值的，值的存取是以KV的形式来进行的。直接上例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> favContextKey <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">    f := <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, k favContextKey)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> v := ctx.Value(k); v != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">"found value:"</span>, v)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(<span class="string">"key not found:"</span>, k)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    k := favContextKey(<span class="string">"language"</span>)</span><br><span class="line">    k1 := favContextKey(<span class="string">"Chinese"</span>)</span><br><span class="line">    ctx := context.WithValue(context.Background(), k, <span class="string">"Go"</span>)</span><br><span class="line">    ctx1 := context.WithValue(ctx, k1, <span class="string">"Go1"</span>)</span><br><span class="line"></span><br><span class="line">    f(ctx1, k1)</span><br><span class="line">    f(ctx1, k)</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">found value: Go1</span><br><span class="line">found value: Go</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Golang最为让人熟知的并发模型当属CSP并发模型，也就是由goroutine和channel构成的&lt;a href=&quot;https://i6448038.github.io/2017/12/04/golang-concurrency-principle/&quot; target=&quot;
      
    
    </summary>
    
    
      <category term="Golang" scheme="http://yoursite.com/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>raft一致性算法详解</title>
    <link href="http://yoursite.com/2018/12/12/raft/"/>
    <id>http://yoursite.com/2018/12/12/raft/</id>
    <published>2018-12-12T10:18:07.000Z</published>
    <updated>2019-07-14T06:17:43.124Z</updated>
    
    <content type="html"><![CDATA[<p>在现实的分布式系统中，不能可能保证集群中的每一台机器都是100%可用可靠的，集群中的任何机器都可能发生宕机、网络连接等问题导致集群中的某个节点不可用，这样，那个节点的数据就有可能和集群不一致，所以需要有一种机制，来保证在大多数机器都存在的情况下向外提供可靠的数据服务。这里的大多数节点指的是<code>集群半数以上</code>的节点。</p><p>raft算法就是一种在分布式系统中解决集群中多节点之间数据一致性的算法。Golang生态圈中大名鼎鼎的etcd就是使用的raft算法来保持数据一致性的，与raft类似的一致性算法还有Paxos算法、Zab协议等。</p><p>其实，raft算法维持数据一致性的核心思想很简单，就是：“少数服从多数”。</p><h1 id="leader选举"><a href="#leader选举" class="headerlink" title="leader选举"></a>leader选举</h1><p>保证数据一致性，最好的方式就是只有唯一的一个节点，唯一的这个节点读，唯一的这个节点写，这样数据肯定是一致的；但是分布式架构显然不可以一个节点，于是，raft算法提出，在集群的所有节点中，需要有一个节点来充当这一个唯一的节点，在一段时间内，只有这一个节点负责读写数据，然后其他节点同步数据。这个唯一的节点叫<code>leader</code>节点，其他负责同步数据的节点叫做<code>follower</code>节点。在集群中，还会有其他状态的节点，例如<code>candidate</code>节点，这种节点只有在选举<code>leader</code>的时候才会有。<br>节点的<code>leader</code>选举和现实生活中的选举十分类似，就是投票，集群中获票数最多的那个，就是<code>leader</code>节点，所以为防止出现平局的情况(平局的情况也有解决方案，下文会说)，一般在部署节点的时候，会将节点数设置为奇数(2n + 1)。</p><p>这些节点是如何选举的呢？我们先从<code>follower</code>、<code>leader</code>、<code>candidate</code>这三种状态说起。<br>在集群中，有三个节点 A 、B、C。</p><!-- ![](/img/raft/WechatIMG8.jpeg) --><p><img src="/img/raft/1.jpeg" alt></p><p>在集群刚刚开始的时候，他们仨都是<code>follower</code>。</p><!-- ![](/img/raft/WechatIMG9.jpeg) --><p><img src="/img/raft/2.jpeg" alt></p><p>过一段时间后，A变成了<code>Candidate</code>，这是要选举了！</p><!-- ![](/img/raft/WechatIMG10.jpeg) --><p><img src="/img/raft/3.jpeg" alt></p><p>为啥A能变成<code>Candidate</code>？凭啥？因为A的<code>election timeout</code>到期了，<code>election timeout</code>是选举超时时间，集群中的每个节点都有一个<code>election timeout</code>，每个节点的<code>election timeout</code>都是150ms ~ 300ms之间的一个随机数。每当节点的<code>election timeout</code>时间到了，就会触发节点变为<code>candidate</code>状态。A的选举超时时间到了，所以A理所当然变为了<code>Candidate</code>。<br>所以，我们知道，其实A、B、C三个节点除了有状态，还有个选举超时时间<code>election timeout</code></p><!-- ![](/img/raft/WechatIMG11.jpeg) --><p><img src="/img/raft/4.jpeg" alt></p><p>此时，<code>candidate</code>节点A会向整个集群发起选举投票，它会先投自己一票，然后告诉B、C 大选开始了！</p><!-- ![](/img/raft/WechatIMG12.jpeg) --><p><img src="/img/raft/5.jpeg" alt></p><p>注意！只有<code>candidate</code>状态的节点，才可以参加竞选变为<code>leader</code>，B、C这两个follower是没有资格的！<br>除此之外，每个节点中还有一个字段，叫<code>term</code>意思就是任期，和美国大选的第几期总统差不多一个意思，这个<code>term</code>是一个全局的、连续递增的整数，每进行一次选举，<code>term</code>就会加一，如果<code>candidate</code>赢得选举，它会当<code>leader</code>直到此次任期结束。<br>此时，A触发了选举，它的<code>term</code>应该是加一的。</p><!-- ![](/img/raft/WechatIMG13.jpeg) --><p><img src="/img/raft/6.jpeg" alt></p><p>当B、C收到A发出的大选消息后，B、C开始投票，此时只有A这一个<code>candidate</code>，所以理所当然发消息都只能投A。</p><!-- ![](/img/raft/WechatIMG14.jpeg) --><p><img src="/img/raft/7.jpeg" alt></p><p>此时A当选<code>leader</code>!<br>为了巩固自己的“统治”，防止A在任期之间其他节点因为自身<code>election timout</code>而触发选举，<code>leader</code>节点A会不定时的向两个<code>follower</code>节点B、C发送心跳消息，B和C收到心跳消息后，会重置<code>election timout</code>。心跳检测时间很短，要远远小于选举超时时间<code>election timout</code>。</p><!-- ![](/img/raft/WechatIMG16.jpeg) --><p><img src="/img/raft/8.jpeg" alt></p><p>B、C收到心跳检测后，返回心跳响应，并重置超时时间<code>election timeout</code>。</p><!-- ![](/img/raft/WechatIMG17.jpeg) --><p><img src="/img/raft/9.jpeg" alt></p><p>假设A发送的心跳检测消息由于网络原因例如延迟、丢包等等没有传送到B、C中的某个Follower节点，而此时这个节点刚好<code>election timeout</code>，则触发选举。<br>C修改自身节点任期值<code>term</code>为2，自身状态变为<code>candidate</code>，且投自身一票后，发起选举！</p><!-- ![](/img/raft/WechatIMG19.jpeg) --><p><img src="/img/raft/10.jpeg" alt></p><p>这时候，由于C的任期值<code>term</code>变为2大于A的，在raft协议中，但收到任期值大于自身的节点，都会更改自身节点的term值，并切换为<code>Follower</code>状态并重置<code>election time</code>。<br>因此，这时候A由<code>leader</code>直接变为<code>Follower</code>！</p><!-- ![](/img/raft/WechatIMG20.jpeg) --><p><img src="/img/raft/11.jpeg" alt></p><p>我们再来考虑一种极端情况：假设有偶数个节点，并且同时有两个节点进入<code>candiate</code>状态！<br>例如有以下四个节点A、B、C、D。A和B同时进入了<code>cadidate</code>状态并开始选举。</p><!-- ![](/img/raft/WechatIMG21.jpeg) --><p><img src="/img/raft/12.jpeg" alt></p><p>假如A和B中任意一个获得了超过半数以上的多数票，则变为leader！</p><!-- ![](/img/raft/WechatIMG22.jpeg) --><p><img src="/img/raft/13.jpeg" alt></p><p>但是假如两个经过一次选举后得的票数相同或者都没有超过半数，则宣告选举失败并结束！等待A和C这两个<code>candidate</code>节点中任意一个节点的<code>election time</code>超时，然后发起新一轮选举。<br>注意：虽然票数相同或者都没有超过半数导致的选举失败了，但是任期值<code>term</code>还是要叠加的！<br>A、B票数相同，等待哪个先超时。</p><!-- ![](/img/raft/WechatIMG23.jpeg) --><p><img src="/img/raft/14.jpeg" alt></p><p>此时A先超时。则A发起选举，由于A<code>term</code>值显然是最大的，则A会最终当选为<code>leader</code>。</p><!-- ![](/img/raft/WechatIMG24.jpeg) --><p><img src="/img/raft/15.jpeg" alt></p><h1 id="日志复制"><a href="#日志复制" class="headerlink" title="日志复制"></a>日志复制</h1><p>当<code>leader</code>选出来后，无论读和写都会由<code>leader</code>节点来处理。<br>是的，读也由<code>leader</code>来处理，<code>leader</code>拿到请求后，再决定由哪一个节点来处理，要么将请求分发，要么自己处理；即使client端请求的是follower节点，Follower节点也会现将请求信息转给<code>leader</code>，再由<code>leader</code>决定由哪个节点来处理。</p><p>下面来说说写的情况：<br>以下有A、B、C三个节点，其中A是<code>leader</code>节点</p><!-- ![](/img/raft/WechatIMG25.jpeg) --><p><img src="/img/raft/16.jpeg" alt></p><p>当client请求过来要求写操作的时候，<code>leader</code> A先把数据写在本身节点的log文件中</p><!-- ![](/img/raft/WechatIMG26.jpeg) --><p><img src="/img/raft/17.jpeg" alt></p><p>然后A将发<code>append entries</code>消息发送给B、C节点。<br>注意！<code>append entries</code>消息其实是根据节点的不同而消息也不同的，因为集群中数据可能不一致，一味的传相同数据，显然不可以。具体怎么不一致，稍后再说。</p><!-- ![](/img/raft/WechatIMG36_new.jpeg) --><p><img src="/img/raft/18.jpeg" alt></p><p>B、C再收到消息后，把数据添加到本地，然后向A发消息，告诉A已经收到。</p><!-- ![](/img/raft/WechatIMG27.jpeg) --><p><img src="/img/raft/19.jpeg" alt></p><p><code>leader</code>A收到后，先提交记录，然后返回客户端响应。</p><!-- ![](/img/raft/WechatIMG28.jpeg) --><p><img src="/img/raft/20.jpeg" alt></p><p>然后，<code>leader</code>A继续向B、C两个follower发送写数据commit的通知。</p><!-- ![](/img/raft/WechatIMG29.jpeg) --><p><img src="/img/raft/21.jpeg" alt></p><p>B、C两个节点收到通知后，先commit自身的log数据，然后再通知<code>leader</code>A已更新结束。</p><!-- ![](/img/raft/WechatIMG30.jpeg) --><p><img src="/img/raft/22.jpeg" alt></p><p>到此整个数据同步也就结束了。<br>每次写数据，都需要先更新，然后commit。每个节点中都有两个索引，一个是当前提交的索引值commitIndex，一个是目前数据的最后一行索引值lastApplied。</p><!-- ![](/img/raft/WechatIMG31.jpeg) --><p><img src="/img/raft/23.jpeg" alt></p><p>而leader节点中，除了需要存储自身节点的commitIndex和lastApplied之外，还需要知道所有<code>Follower</code>的存储情况，因而<code>leader</code>节点中多了一张表，这张表中记录了所有<code>follower</code>节点的存储情况，这张表中有两个属性，一个属性叫<code>nextIndex</code>记录的是<code>Follower</code>节点没有的数据索引，需要发送<code>append entries</code>的数据索引；还有一个<code>matchIndex</code>记录的是<code>leader</code>节点已知的，<code>follower</code>节点的数据。如下图所示:</p><!-- ![](/img/raft/WechatIMG32.jpeg) --><p><img src="/img/raft/24.jpeg" alt></p><p>因此，当数据更新的时候，<code>leader</code>A 向节点B、C发送不同的<code>append entries</code>。</p><!-- ![](/img/raft/WechatIMG33.jpeg) --><p><img src="/img/raft/25.jpeg" alt></p><p>当A节点不再当leader时，其他节点并不能知道<code>leader</code>A保存的<code>matchIndex</code>和<code>nextIndex</code>这两个数组的数据。当其他节点成功当选为<code>leader</code>节点后，会将<code>nextIndex</code>全部重置为自身的<code>commitIndex</code>，而<code>matchIndex</code>则全部重置为0。如下图：</p><!-- ![](/img/raft/WechatIMG34.jpeg) --><p><img src="/img/raft/26.jpeg" alt></p><p>则，<code>leader</code>B会向A和C节点发<code>append entries</code>，去”补全”数据</p><!-- ![](/img/raft/WechatIMG35.jpeg) --><p><img src="/img/raft/27.jpeg" alt></p><p>节点收到请求后，如果存在数据，就不动直接返回，如果没有数据则缺哪个补哪个。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>触发选举的唯一条件是<code>election timeout</code>，心跳超时等其他条件仅仅是触发了非<code>leader</code>节点的<code>election timeout</code>。</li><li>节点选举的时候，<code>term</code>值大的一定会力压<code>term</code>值小的当选leader。</li><li><code>leader</code>节点向<code>follower</code>节点中发送<code>append entries</code>的时候，并不是缺少1、2、3就直接发送1、2、3而是分批次，一次发送一条。1！ 2！ 3！三条数据，分三次发完。(怕图片误导，特此说明!)</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在现实的分布式系统中，不能可能保证集群中的每一台机器都是100%可用可靠的，集群中的任何机器都可能发生宕机、网络连接等问题导致集群中的某个节点不可用，这样，那个节点的数据就有可能和集群不一致，所以需要有一种机制，来保证在大多数机器都存在的情况下向外提供可靠的数据服务。这里的
      
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Go语言interface底层实现</title>
    <link href="http://yoursite.com/2018/10/01/Golang-interface/"/>
    <id>http://yoursite.com/2018/10/01/Golang-interface/</id>
    <published>2018-09-30T18:04:16.000Z</published>
    <updated>2019-07-14T06:17:43.127Z</updated>
    
    <content type="html"><![CDATA[<p>Go的interface源码在Golang源码的<code>runtime</code>目录中。<br>Go在不同版本之间的interface结构可能会有所不同，但是，整体的结构是不会改变的，此文章用的Go版本是1.11。</p><p>Go的interface是由两种类型来实现的：<code>iface</code>和<code>eface</code>。<br>其中，<code>iface</code>表示的是包含方法的interface，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">interface</span> &#123;</span><br><span class="line">Print()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而<code>eface</code>代表的是不包含方法的interface，即</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">interface</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person <span class="keyword">interface</span>&#123;&#125; = xxxx实体</span><br></pre></td></tr></table></figure><h2 id="eface"><a href="#eface" class="headerlink" title="eface"></a><code>eface</code></h2><p><code>eface</code>的具体结构是：<br><img src="/img/interface/eface.png" alt="在这里插入图片描述"><br>一共有两个属性构成，一个是类型信息<code>_type</code>，一个是数据信息。<br>其中，<code>_type</code>可以认为是Go语言中所有类型的公共描述，Go语言中几乎所有的数据结构都可以抽象成<code>_type</code>，是所有类型的表现，可以说是万能类型，<br><code>data</code>是指向具体数据的指针。</p><p><code>type</code>的具体代码为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> _type <span class="keyword">struct</span> &#123;</span><br><span class="line">size       <span class="keyword">uintptr</span> </span><br><span class="line">ptrdata    <span class="keyword">uintptr</span> <span class="comment">// size of memory prefix holding all pointers</span></span><br><span class="line">hash       <span class="keyword">uint32</span></span><br><span class="line">tflag      tflag</span><br><span class="line">align      <span class="keyword">uint8</span></span><br><span class="line">fieldalign <span class="keyword">uint8</span></span><br><span class="line">kind       <span class="keyword">uint8</span></span><br><span class="line">alg        *typeAlg</span><br><span class="line"><span class="comment">// gcdata stores the GC type data for the garbage collector.</span></span><br><span class="line"><span class="comment">// If the KindGCProg bit is set in kind, gcdata is a GC program.</span></span><br><span class="line"><span class="comment">// Otherwise it is a ptrmask bitmap. See mbitmap.go for details.</span></span><br><span class="line">gcdata    *<span class="keyword">byte</span></span><br><span class="line">str       nameOff</span><br><span class="line">ptrToThis typeOff</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>eface</code>的整体结构是：<br><img src="/img/interface/eface_all.png" alt="在这里插入图片描述"><br>对于没有方法的interface赋值后的内部结构是怎样的呢？<br>可以先看段代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"strconv"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Binary <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">b := Binary(<span class="number">200</span>)</span><br><span class="line">any := (<span class="keyword">interface</span>&#123;&#125;)(b)</span><br><span class="line">fmt.Println(any)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出200，赋值后的结构图是这样的：<br><img src="/img/interface/eface_fuzhi.png" alt="在这里插入图片描述"><br>对于将不同类型转化成<code>type</code>万能结构的方法，是运行时的<code>convT2E</code>方法，在<code>runtime</code>包中。<br>以上，是对于没有方法的接口说明。<br>对于包含方法的函数，用到的是另外的一种结构，叫<code>iface</code></p><h1 id="iface"><a href="#iface" class="headerlink" title="iface"></a><code>iface</code></h1><p>所有包含方法的接口，都会使用<code>iface</code>结构。包含方法的接口就是一下这种最常见，最普通的接口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">interface</span> &#123;</span><br><span class="line">Print()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>iface</code>的源代码是：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> &#123;</span><br><span class="line">tab  *itab</span><br><span class="line">data unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>iface</code>的具体结构是：</p><p><img src="/img/interface/iface.png" alt="在这里插入图片描述"></p><p><code>itab</code>是<code>iface</code>不同于<code>eface</code>比较关键的数据结构。其可包含两部分：一部分是确定唯一的包含方法的interface的具体结构类型，一部分是指向具体方法集的指针。<br>具体结构为：<br><img src="/img/interface/iface_itable.png" alt="在这里插入图片描述"><br>属性 <code>itab</code>的源代码是：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> itab <span class="keyword">struct</span> &#123;</span><br><span class="line">inter *interfacetype <span class="comment">//此属性用于定位到具体interface</span></span><br><span class="line">_type *_type <span class="comment">//此属性用于定位到具体interface</span></span><br><span class="line">hash  <span class="keyword">uint32</span> <span class="comment">// copy of _type.hash. Used for type switches.</span></span><br><span class="line">_     [<span class="number">4</span>]<span class="keyword">byte</span></span><br><span class="line">fun   [<span class="number">1</span>]<span class="keyword">uintptr</span> <span class="comment">// variable sized. fun[0]==0 means _type does not implement inter.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>属性<code>interfacetype</code>类似于<code>_type</code>，其作用就是interface的公共描述，类似的还有<code>maptype</code>、<code>arraytype</code>、<code>chantype</code>…其都是各个结构的公共描述，可以理解为一种外在的表现信息。<code>interfacetype</code>源码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> interfacetype <span class="keyword">struct</span> &#123;</span><br><span class="line">typ     _type</span><br><span class="line">pkgpath name</span><br><span class="line">mhdr    []imethod</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> imethod <span class="keyword">struct</span> &#123;</span><br><span class="line">name nameOff</span><br><span class="line">ityp typeOff</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>iface</code>的整体结构为：</p><p><img src="/img/interface/iface_all.png" alt="在这里插入图片描述"></p><p>对于含有方法的interface赋值后的内部结构是怎样的呢？<br>一下代码运行后</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"strconv"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Binary <span class="keyword">uint64</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i Binary)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> strconv.FormatUint(i.Get(), <span class="number">10</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i Binary)</span> <span class="title">Get</span><span class="params">()</span> <span class="title">uint64</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">uint64</span>(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">b := Binary(<span class="number">200</span>)</span><br><span class="line">any := fmt.Stringer(b)</span><br><span class="line">fmt.Println(any)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，要知道代码运行结果为:200。<br>其次，了解到<code>fmt.Stringer</code>是一个包含<code>String</code>方法的接口。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stringer <span class="keyword">interface</span> &#123;</span><br><span class="line">String() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，赋值后接口<code>Stringer</code>的内部结构为：<br><img src="/img/interface/iface_fuzhi.png" alt="在这里插入图片描述"></p><p>对于将不同类型转化成itable中<code>type(Binary)</code>的方法，是运行时的<code>convT2I</code>方法，在<code>runtime</code>包中。</p><p>参考文献：<br>《Go in action》<br><a href="https://research.swtch.com/interfaces" target="_blank" rel="noopener">https://research.swtch.com/interfaces</a><br><a href="https://juejin.im/entry/5a7d08d3f265da4e865a6200" target="_blank" rel="noopener">https://juejin.im/entry/5a7d08d3f265da4e865a6200</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Go的interface源码在Golang源码的&lt;code&gt;runtime&lt;/code&gt;目录中。&lt;br&gt;Go在不同版本之间的interface结构可能会有所不同，但是，整体的结构是不会改变的，此文章用的Go版本是1.11。&lt;/p&gt;
&lt;p&gt;Go的interface是由两种类型
      
    
    </summary>
    
    
      <category term="golang" scheme="http://yoursite.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>解剖Go语言map底层实现</title>
    <link href="http://yoursite.com/2018/08/26/map-secret/"/>
    <id>http://yoursite.com/2018/08/26/map-secret/</id>
    <published>2018-08-25T18:43:04.000Z</published>
    <updated>2019-07-14T06:17:43.129Z</updated>
    
    <content type="html"><![CDATA[<p><code>map</code>是Go语言中基础的数据结构，在日常的使用中经常被用到。但是它底层是如何实现的呢？</p><p>Golang中<code>map</code>的底层实现是一个散列表，因此实现<code>map</code>的过程实际上就是实现散表的过程。在这个散列表中，主要出现的结构体有两个，一个叫<code>hmap</code>(<code>a header for a go map</code>)，一个叫<code>bmap</code>(<code>a bucket for a Go map</code>，通常叫其<code>bucket</code>)。这两种结构的样子分别如下所示：<br>hmap:</p><img src="/img/go_map/hmap.png"><p>图中有很多字段，但是便于理解<code>map</code>的架构，你只需要关心的只有一个，就是标红的字段：buckets数组。Golang的map中用于存储的结构是bucket数组。而bucket(即<code>bmap</code>)的结构是怎样的呢？</p><p>bucket：</p><img src="/img/go_map/bmap.png"><p>相比于<code>hmap</code>，bucket的结构显得简单一些，标红的字段依然是“核心”，我们使用的<code>map</code>中的key和value就存储在这里。“高位哈希值”数组记录的是当前bucket中key相关的“索引”，稍后会详细叙述。还有一个字段是一个指向扩容后的bucket的指针，使得bucket会形成一个链表结构。例如下图：</p><img src="/img/go_map/bmap_chain.png"><p>由此看出<code>hmap</code>和<code>bucket</code>的关系是这样的：</p><p><img src="/img/go_map/hmap_bmap.png" alt="这里写图片描述"></p><p>而bucket又是一个链表，所以，整体的结构应该是这样的：</p><p><img src="/img/go_map/whole.png" alt="这里写图片描述"></p><p>哈希表的特点是会有一个哈希函数，对你传来的key进行哈希运算，得到唯一的值，一般情况下都是一个数值。Golang的<code>map</code>中也有这么一个哈希函数，也会算出唯一的值，对于这个值的使用，Golang也是很有意思。</p><p>Golang把求得的值按照用途一分为二：高位和低位。</p><p><img src="/img/go_map/num.png" alt="这里写图片描述"></p><p>如图所示，蓝色为高位，红色为低位。<br>然后低位用于寻找当前key属于<code>hmap</code>中的哪个bucket，而高位用于寻找bucket中的哪个key。上文中提到：bucket中有个属性字段是“高位哈希值”数组，这里存的就是蓝色的高位值，用来声明当前bucket中有哪些“key”，便于搜索查找。<br>需要特别指出的一点是：我们<code>map</code>中的key/value值都是存到同一个数组中的。数组中的顺序是这样的:</p><p><img src="/img/go_map/key_value.png" alt="这里写图片描述"></p><p>并不是key0/value0/key1/value1的形式，这样做的好处是：在key和value的长度不同的时候，可以消除padding带来的空间浪费。</p><p>现在，我们可以得到Go语言<code>map</code>的整个的结构图了：</p><p><img src="/img/go_map/all_elem.png" alt="这里写图片描述"></p><h1 id="map的扩容"><a href="#map的扩容" class="headerlink" title="map的扩容"></a><code>map</code>的扩容</h1><p>当以上的哈希表增长的时候，Go语言会将bucket数组的数量扩充一倍，产生一个新的bucket数组，并将旧数组的数据迁移至新数组。</p><h2 id="加载因子"><a href="#加载因子" class="headerlink" title="加载因子"></a>加载因子</h2><p>判断扩充的条件，就是哈希表中的<code>加载因子</code>(即loadFactor)。</p><p><code>加载因子</code>是一个阈值，一般表示为：散列包含的元素数 除以 位置总数。是一种“产生冲突机会”和“空间使用”的平衡与折中：<code>加载因子</code>越小，说明空间空置率高，空间使用率小，但是<code>加载因子</code>越大，说明空间利用率上去了，但是“产生冲突机会”高了。</p><p>每种哈希表的都会有一个<code>加载因子</code>，数值超过<code>加载因子</code>就会为哈希表扩容。<br>Golang的<code>map</code>的<code>加载因子</code>的公式是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map长度 / 2^B</span><br></pre></td></tr></table></figure><p>阈值是<code>6.5</code>。其中<code>B</code>可以理解为已扩容的次数。<br>当Go的<code>map</code>长度增长到大于<code>加载因子</code>所需的<code>map</code>长度时，Go语言就会将产生一个新的bucket数组，然后把旧的bucket数组移到一个属性字段<code>oldbucket</code>中。注意：并不是立刻把旧的数组中的元素转义到新的bucket当中，而是，只有当访问到具体的某个bucket的时候，会把bucket中的数据转移到新的bucket中。</p><p>如下图所示：当扩容的时候，Go的<code>map</code>结构体中，会保存旧的数据，和新生成的数组</p><p><img src="/img/go_map/extends.png" alt="这里写图片描述"></p><p>上面部分代表旧的有数据的bucket，下面部分代表新生成的新的bucket。蓝色代表存有数据的bucket，橘黄色代表空的bucket。<br>扩容时<code>map</code>并不会立即把新数据做迁移，而是当访问原来旧bucket的数据的时候，才把旧数据做迁移，如下图：</p><p><img src="/img/go_map/move_bucket.png" alt="这里写图片描述"></p><p>注意：这里并不会直接删除旧的bucket，而是把原来的引用去掉，利用GC清除内存。</p><h1 id="map中数据的删除"><a href="#map中数据的删除" class="headerlink" title="map中数据的删除"></a><code>map</code>中数据的删除</h1><p>如果理解了<code>map</code>的整体结构，那么查找、更新、删除的基本步骤应该都很清楚了。这里不再赘述。<br>值得注意的是，找到了<code>map</code>中的数据之后，针对key和value分别做如下操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、如果``key``是一个指针类型的，则直接将其置为空，等待GC清除；</span><br><span class="line">2、如果是值类型的，则清除相关内存。</span><br><span class="line">3、同理，对``value``做相同的操作。</span><br><span class="line">4、最后把key对应的高位值对应的数组index置为空。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;map&lt;/code&gt;是Go语言中基础的数据结构，在日常的使用中经常被用到。但是它底层是如何实现的呢？&lt;/p&gt;
&lt;p&gt;Golang中&lt;code&gt;map&lt;/code&gt;的底层实现是一个散列表，因此实现&lt;code&gt;map&lt;/code&gt;的过程实际上就是实现散表的过程。在这
      
    
    </summary>
    
    
      <category term="Golang" scheme="http://yoursite.com/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>快速理解Go数组和切片的内部实现原理</title>
    <link href="http://yoursite.com/2018/08/11/array-and-slice-principle/"/>
    <id>http://yoursite.com/2018/08/11/array-and-slice-principle/</id>
    <published>2018-08-11T08:36:24.000Z</published>
    <updated>2019-09-30T06:18:21.960Z</updated>
    
    <content type="html"><![CDATA[<p>   很多人对Go语言的<code>array</code>和<code>slice</code>傻傻分不清楚，今天我们就从底层出发，来聊聊它俩到底有什么区别。</p><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>   几乎所有计算机语言，数组的实现都是相似的：一段连续的内存，Go语言也一样，Go语言的数组底层实现就是一段连续的内存空间。每个元素有唯一一个索引(或者叫<code>下标</code>)来访问。如下图所示，下图是<code>[5]int{1:10, 2:20}</code>数组的内部实现逻辑图:</p><p><img src="/img/slice/array.png" alt="image"></p><p>  由于内存连续，CPU很容易计算索引(即数组的<code>下标</code>)，可以快速迭代数组里的所有元素。<br>  Go语言的数组不同于C语言或者其他语言的数组，C语言的数组变量是指向数组第一个元素的指针；而Go语言的数组是一个值，Go语言中的数组是值类型，一个数组变量就表示着整个数组，意味着Go语言的数组在传递的时候，传递的是原数组的拷贝。你可以理解为Go语言的数组是一种有序的<code>struct</code></p><h1 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h1><p>  切片是一个很小的对象，是对数组进行了抽象，并提供相关的操作方法。切片有三个属性字段：长度、容量和指向数组的指针。</p><p>  <img src="/img/slice/slice_1.png" alt="image"></p><p>  上图中，<code>ptr</code>指的是指向array的pointer，<code>len</code>是指切片的长度, <code>cap</code>指的是切片的容量。现在，我想你对数组和切片有了一个本质的认识。</p><h2 id="切片有多种声明方式，每种初始化方式对应的逻辑图是怎样的呢？"><a href="#切片有多种声明方式，每种初始化方式对应的逻辑图是怎样的呢？" class="headerlink" title="切片有多种声明方式，每种初始化方式对应的逻辑图是怎样的呢？"></a>切片有多种声明方式，每种初始化方式对应的逻辑图是怎样的呢？</h2><h3 id="对于s-make-byte-5-和s-byte-的方式"><a href="#对于s-make-byte-5-和s-byte-的方式" class="headerlink" title="对于s := make([]byte, 5)和s := []byte{...}的方式"></a>对于<code>s := make([]byte, 5)</code>和<code>s := []byte{...}</code>的方式</h3><p>  <img src="/img/slice/slice2.png" alt="image"></p><h3 id="对于s-s-2-4-的方式"><a href="#对于s-s-2-4-的方式" class="headerlink" title="对于s = s[2:4]的方式"></a>对于<code>s = s[2:4]</code>的方式</h3><p>  <img src="/img/slice/slice3.png" alt="image"></p><h3 id="对于nil的切片即var-s-byte对应的逻辑图是"><a href="#对于nil的切片即var-s-byte对应的逻辑图是" class="headerlink" title="对于nil的切片即var s []byte对应的逻辑图是"></a>对于<code>nil</code>的切片即<code>var s []byte</code>对应的逻辑图是</h3><p>  <img src="/img/slice/slice4.png" alt="image"></p><p>  在此有一个说明：<code>nil</code>切片和<code>空</code>切片是不太一样的，空切片即<code>s := make([]byte, 0)</code>或者<code>s := []byte{}</code>出来的切片<br>  空切片的逻辑图为：</p><p>  <img src="/img/slice/slice5.png" alt="image"></p><p>  空切片指针不为nil，而nil切片指针为nil。但是，不管是空切片还是nil切片，对其调用内置函数<code>append()</code>、<code>len</code>和<code>cap</code>的效果都是一样的，感受不到任何区别。</p><h2 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h2><p>  slice这种数据结构便于使用和管理数据集合，可以理解为是一种“动态数组”，<code>slice</code>也是围绕动态数组的概念来构建的。既然是动态数组，那么slice是如何扩容的呢？</p><p>  请记住以下两条规则：</p><ul><li>如果切片的容量小于1024个元素，那么扩容的时候slice的cap就翻番，乘以2；一旦元素个数超过1024个元素，增长因子就变成1.25，即每次增加原来容量的四分之一。</li><li>如果扩容之后，还没有触及原数组的容量，那么，切片中的指针指向的位置，就还是原数组，如果扩容之后，超过了原数组的容量，那么，Go就会开辟一块新的内存，把原来的值拷贝过来，这种情况丝毫不会影响到原数组。</li></ul><p>知道了一下规则，请看下面程序,试问输出结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    arr := [<span class="number">4</span>]<span class="keyword">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>&#125;</span><br><span class="line">    slice := arr[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line">    testSlice1 := slice</span><br><span class="line">    testSlice2 := <span class="built_in">append</span>(<span class="built_in">append</span>(<span class="built_in">append</span>(slice, <span class="number">1</span>),<span class="number">2</span>),<span class="number">3</span>)</span><br><span class="line">    slice[<span class="number">0</span>] = <span class="number">11</span></span><br><span class="line">  </span><br><span class="line">    fmt.Println(testSlice1[<span class="number">0</span>])</span><br><span class="line">    fmt.Println(testSlice2[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">11</span><br><span class="line">10</span><br></pre></td></tr></table></figure><p>答对了吗？</p><p>参考文献:<br>《Go in action》<br><a href="https://blog.golang.org/go-slices-usage-and-internals" target="_blank" rel="noopener">https://blog.golang.org/go-slices-usage-and-internals</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;   很多人对Go语言的&lt;code&gt;array&lt;/code&gt;和&lt;code&gt;slice&lt;/code&gt;傻傻分不清楚，今天我们就从底层出发，来聊聊它俩到底有什么区别。&lt;/p&gt;
&lt;h1 id=&quot;数组&quot;&gt;&lt;a href=&quot;#数组&quot; class=&quot;headerlink&quot; title=&quot;
      
    
    </summary>
    
    
      <category term="golang" scheme="http://yoursite.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>golang错题集</title>
    <link href="http://yoursite.com/2018/07/18/golang-mistakes/"/>
    <id>http://yoursite.com/2018/07/18/golang-mistakes/</id>
    <published>2018-07-17T16:17:28.000Z</published>
    <updated>2019-07-14T06:17:43.116Z</updated>
    
    <content type="html"><![CDATA[<p>本文即<a href="https://i6448038.github.io/2017/07/28/GolangDetails/" target="_blank" rel="noopener">Go语言的那些坑</a>三。</p><h1 id="不要对Go并发函数的执行时机做任何假设"><a href="#不要对Go并发函数的执行时机做任何假设" class="headerlink" title="不要对Go并发函数的执行时机做任何假设"></a>不要对Go并发函数的执行时机做任何假设</h1><p>请看下列的列子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"runtime"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">names := []<span class="keyword">string</span>&#123;<span class="string">"lily"</span>, <span class="string">"yoyo"</span>, <span class="string">"cersei"</span>, <span class="string">"rose"</span>, <span class="string">"annei"</span>&#125;</span><br><span class="line"><span class="keyword">for</span> _, name := <span class="keyword">range</span> names&#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">fmt.Println(name)</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">runtime.GOMAXPROCS(<span class="number">1</span>)</span><br><span class="line">runtime.Gosched()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请问输出什么？</p><p>答案:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">annei</span><br><span class="line">annei</span><br><span class="line">annei</span><br><span class="line">annei</span><br><span class="line">annei</span><br></pre></td></tr></table></figure><p>为什么呢？是不是有点诧异？<br>输出的都是“annei”，而“annei”又是“names”的最后一个元素，那么也就是说程序打印出了最后一个元素的值，而name对于匿名函数来讲又是一个外部的值。因此，我们可以做一个推断：虽然每次循环都启用了一个协程，但是这些协程都是引用了外部的变量，当协程创建完毕，再执行打印动作的时候，name的值已经不知道变为啥了，因为主函数协程也在跑，大家并行，但是在此由于names数组长度太小，当协程创建完毕后，主函数循环早已结束，所以，打印出来的都是遍历的names最后的那一个元素“annei”。<br>如何证实以上的推断呢？<br>其实很简单，每次循环结束后，停顿一段时间，等待协程打印当前的name便可。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"runtime"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">names := []<span class="keyword">string</span>&#123;<span class="string">"lily"</span>, <span class="string">"yoyo"</span>, <span class="string">"cersei"</span>, <span class="string">"rose"</span>, <span class="string">"annei"</span>&#125;</span><br><span class="line"><span class="keyword">for</span> _, name := <span class="keyword">range</span> names&#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">fmt.Println(name)</span><br><span class="line">&#125;()</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line">runtime.GOMAXPROCS(<span class="number">1</span>)</span><br><span class="line">runtime.Gosched()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lily</span><br><span class="line">yoyo</span><br><span class="line">cersei</span><br><span class="line">rose</span><br><span class="line">annei</span><br></pre></td></tr></table></figure><p>以上我们得出一个结论，不要对“go函数”的执行时机做任何的假设，除非你确实能做出让这种假设成为绝对事实的保证。</p><h1 id="假设T类型的方法上接收器既有T类型的，又有-T指针类型的，那么就不可以在不能寻址的T值上调用-T接收器的方法"><a href="#假设T类型的方法上接收器既有T类型的，又有-T指针类型的，那么就不可以在不能寻址的T值上调用-T接收器的方法" class="headerlink" title="假设T类型的方法上接收器既有T类型的，又有*T指针类型的，那么就不可以在不能寻址的T值上调用*T接收器的方法"></a>假设T类型的方法上接收器既有<code>T</code>类型的，又有<code>*T</code>指针类型的，那么就不可以在不能寻址的T值上调用<code>*T</code>接收器的方法</h1><p>请看代码,试问能正常编译通过吗？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> Lili <span class="keyword">struct</span>&#123;</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Lili *Lili)</span> <span class="title">fmtPointer</span><span class="params">()</span></span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"poniter"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Lili Lili)</span> <span class="title">fmtReference</span><span class="params">()</span></span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"reference"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">li := Lili&#123;&#125;</span><br><span class="line">li.fmtPointer()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">能正常编译通过，并输出&quot;poniter&quot;</span><br></pre></td></tr></table></figure><p>感觉有点诧异，请接着看以下的代码，试问能编译通过？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> Lili <span class="keyword">struct</span>&#123;</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Lili *Lili)</span> <span class="title">fmtPointer</span><span class="params">()</span></span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"poniter"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Lili Lili)</span> <span class="title">fmtReference</span><span class="params">()</span></span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"reference"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">Lili&#123;&#125;.fmtPointer()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">不能编译通过。</span><br><span class="line">“cannot call pointer method on Lili literal”</span><br><span class="line">“cannot take the address of Lili literal”</span><br></pre></td></tr></table></figure><p>是不是有点奇怪？这是为什么呢？其实在第一个代码示例中，main主函数中的“li”是一个变量，li的虽然是类型Lili，但是li是可以寻址的，&amp;li的类型是<code>*Lili</code>，因此可以调用*Lili的方法。</p><h1 id="一个包含nil指针的接口不是nil接口"><a href="#一个包含nil指针的接口不是nil接口" class="headerlink" title="一个包含nil指针的接口不是nil接口"></a>一个包含nil指针的接口不是nil接口</h1><p>请看下列代码，试问返回什么</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bytes"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"io"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> debug = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">var</span> buf *bytes.Buffer</span><br><span class="line"><span class="keyword">if</span> debug&#123;</span><br><span class="line">buf = <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">&#125;</span><br><span class="line">f(buf)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(out io.Writer)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> out != <span class="literal">nil</span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"surprise!"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案是输出：surprise。<br>ok，让我们吧<code>debug</code>开关关掉，及<code>debug</code>的值变为<code>false</code>。那么输出什么呢？是不是什么都不输出？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bytes"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"io"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> debug = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">var</span> buf *bytes.Buffer</span><br><span class="line"><span class="keyword">if</span> debug&#123;</span><br><span class="line">buf = <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">&#125;</span><br><span class="line">f(buf)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(out io.Writer)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> out != <span class="literal">nil</span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"surprise!"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案是：依然输出surprise。</p><p>这是为什么呢？<br>这就牵扯到一个概念了，是关于接口值的。概念上讲一个接口的值分为两部分：一部分是类型，一部分是类型对应的值，他们分别叫：动态类型和动态值。类型系统是针对编译型语言的，类型是编译期的概念，因此类型不是一个值。<br>在上述代码中，给f函数的out参数赋了一个<code>*bytes.Buffer</code>的空指针，所以out的动态值是nil。然而它的动态类型是<em>bytes.Buffer，意思是：“A non-nil interface containing a nil pointer”，所以“out!=nil”的结果依然是true。<br>但是，对于直接的``</em>bytes.Buffer``类型的判空不会出现此问题。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bytes"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">var</span> buf *bytes.Buffer</span><br><span class="line"><span class="keyword">if</span> buf == <span class="literal">nil</span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"right"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还是输出: right<br>只有 接口指针 传入函数的接口参数时，才会出现以上的坑。<br>修改起来也很方便，把<code>*bytes.Buffer</code>改为<code>io.Writer</code>就好了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bytes"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"io"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> debug = <span class="literal">false</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">var</span> buf  io.Writer <span class="comment">//原来是var buf *bytes.Buffer</span></span><br><span class="line"><span class="keyword">if</span> debug&#123;</span><br><span class="line">buf = <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">&#125;</span><br><span class="line">f(buf)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(out io.Writer)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> out != <span class="literal">nil</span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"surprise!"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="将map转化为json字符串的时候，json字符串中的顺序和map赋值顺序无关"><a href="#将map转化为json字符串的时候，json字符串中的顺序和map赋值顺序无关" class="headerlink" title="将map转化为json字符串的时候，json字符串中的顺序和map赋值顺序无关"></a>将map转化为json字符串的时候，json字符串中的顺序和map赋值顺序无关</h1><p>请看下列代码，请问输出什么？若为json字符串，则json字符串中key的顺序是什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">params := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line">params[<span class="string">"id"</span>] = <span class="string">"1"</span></span><br><span class="line">params[<span class="string">"id1"</span>] = <span class="string">"3"</span></span><br><span class="line">params[<span class="string">"controller"</span>] = <span class="string">"sections"</span></span><br><span class="line"></span><br><span class="line">data, _ := json.Marshal(params)</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(data))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案：输出<code>{&quot;controller&quot;:&quot;sections&quot;,&quot;id&quot;:&quot;1&quot;,&quot;id1&quot;:&quot;3&quot;}</code><br>利用Golang自带的json转换包转换，会将map中key的顺序改为字母顺序，而不是map的赋值顺序。map这个结构哪怕利用<code>for range</code>遍历的时候,其中的key也是无序的，可以理解为map就是个无序的结构，和php中的array要区分开来</p><h1 id="Json反序列化数字到interface-类型的值中，默认解析为float64类型"><a href="#Json反序列化数字到interface-类型的值中，默认解析为float64类型" class="headerlink" title="Json反序列化数字到interface{}类型的值中，默认解析为float64类型"></a>Json反序列化数字到interface{}类型的值中，默认解析为float64类型</h1><p>请看以下程序，程序想要输出json数据中整型<code>id</code>加上<code>3</code>的值,请问程序会报错吗？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">jsonStr := <span class="string">`&#123;"id":1058,"name":"RyuGou"&#125;`</span></span><br><span class="line"><span class="keyword">var</span> jsonData <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">json.Unmarshal([]<span class="keyword">byte</span>(jsonStr), &amp;jsonData)</span><br><span class="line"></span><br><span class="line">sum :=  jsonData[<span class="string">"id"</span>].(<span class="keyword">int</span>) + <span class="number">3</span></span><br><span class="line">fmt.Println(sum)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string">答案是会报错，输出结果为：</span></span><br></pre></td></tr></table></figure><p>panic: interface conversion: interface {} is float64, not int</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用 Golang 解析 JSON  格式数据时，若以 interface&#123;&#125; 接收数据，则会按照下列规则进行解析：</span><br></pre></td></tr></table></figure><p>bool, for JSON booleans</p><p>float64, for JSON numbers</p><p>string, for JSON strings</p><p>[]interface{}, for JSON arrays</p><p>map[string]interface{}, for JSON objects</p><p>nil for JSON null</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">应该改为：</span><br><span class="line">```go</span><br><span class="line">func main()&#123;</span><br><span class="line">jsonStr := `&#123;&quot;id&quot;:1058,&quot;name&quot;:&quot;RyuGou&quot;&#125;`</span><br><span class="line">var jsonData map[string]interface&#123;&#125;</span><br><span class="line">json.Unmarshal([]byte(jsonStr), &amp;jsonData)</span><br><span class="line"></span><br><span class="line">sum :=  int(jsonData[&quot;id&quot;].(float64)) + 3</span><br><span class="line">fmt.Println(sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="即使在有多个变量、且有的变量存在有的变量不存在、且这些变量共同赋值的情况下，也不可以使用-来给全局变量赋值"><a href="#即使在有多个变量、且有的变量存在有的变量不存在、且这些变量共同赋值的情况下，也不可以使用-来给全局变量赋值" class="headerlink" title="即使在有多个变量、且有的变量存在有的变量不存在、且这些变量共同赋值的情况下，也不可以使用:=来给全局变量赋值"></a>即使在有多个变量、且有的变量存在有的变量不存在、且这些变量共同赋值的情况下，也不可以使用<code>:=</code>来给全局变量赋值</h1><p><code>:=</code>往往是用来声明局部变量的，在多个变量赋值且有的值存在的情况下，<code>:=</code>也可以用来赋值使用,例如:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">msgStr := <span class="string">"hello wolrd"</span></span><br><span class="line">msgStr, err := <span class="string">"hello"</span>, errors.New(<span class="string">"xxx"</span>)<span class="comment">//err并不存在</span></span><br></pre></td></tr></table></figure><p>但是，假如全局变量也使用类似的方式赋值，就会出现问题，请看下列代码，试问能编译通过吗？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> varTest <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">varTest, err := function()</span><br><span class="line">fmt.Println(err.Error())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">function</span><span class="params">()</span><span class="params">(<span class="keyword">string</span>, error)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"hello world"</span>, errors.New(<span class="string">"error"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">test()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案是：通不过。输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">varTest declared and not used</span><br></pre></td></tr></table></figure><p>但是如果改成如下代码，就可以通过：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> varTest <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">err := errors.New(<span class="string">"error"</span>)</span><br><span class="line">varTest, err = function()</span><br><span class="line">fmt.Println(err.Error())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">function</span><span class="params">()</span><span class="params">(<span class="keyword">string</span>, error)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"hello world"</span>, errors.New(<span class="string">"error"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">test()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error</span><br></pre></td></tr></table></figure><p>这是什么原因呢？<br>答案其实很简单，在<code>test</code>方法中，如果使用<code>varTest, err := function()</code>这种方式的话，相当于在函数中又定义了一个和全局变量<code>varTest</code>名字相同的局部变量，而这个局部变量又没有使用，所以会编译不通过。</p><h1 id="interface-是一个指向interface的指针类型，而不是interface类型"><a href="#interface-是一个指向interface的指针类型，而不是interface类型" class="headerlink" title="*interface 是一个指向interface的指针类型，而不是interface类型"></a>*interface 是一个指向interface的指针类型，而不是interface类型</h1><p>请问以下代码，能编译通过吗？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Father <span class="keyword">interface</span> &#123;</span><br><span class="line">Hello()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Child <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Child)</span><span class="title">Hello</span><span class="params">()</span></span>  &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">var</span> buf  Child</span><br><span class="line">buf = Child&#123;&#125;</span><br><span class="line">f(&amp;buf)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(out *Father)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> out != <span class="literal">nil</span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"surprise!"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案是：不能编译通过。输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*Father is pointer to interface, not interface</span><br></pre></td></tr></table></figure><p>注意了：接口类型的变量可以被赋值为实现接口的结构体的实例，但是并不能代表接口的指针可以被赋值为实现接口的结构体的指针实例。即：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buf Father = Child&#123;&#125;</span><br></pre></td></tr></table></figure><p>是对的，但是</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buf *Father = <span class="built_in">new</span>(Child)</span><br></pre></td></tr></table></figure><p>却是不对的。应该改为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buf Father = Child&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> pointer *Father = &amp;buf</span><br></pre></td></tr></table></figure><p>要想让问题最开始的代码编译通过要将以上代码修改为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Father <span class="keyword">interface</span> &#123;</span><br><span class="line">Hello()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Child <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Child)</span><span class="title">Hello</span><span class="params">()</span></span>  &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">var</span> buf  Father</span><br><span class="line">buf = Child&#123;&#125;</span><br><span class="line">f(&amp;buf)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(out *Father)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> out != <span class="literal">nil</span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"surprise!"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文即&lt;a href=&quot;https://i6448038.github.io/2017/07/28/GolangDetails/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Go语言的那些坑&lt;/a&gt;三。&lt;/p&gt;
&lt;h1 id=&quot;不要对Go并发函数的执行时
      
    
    </summary>
    
    
      <category term="golang" scheme="http://yoursite.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>比特币和区块链</title>
    <link href="http://yoursite.com/2018/05/08/bitcoin-and-blockchain/"/>
    <id>http://yoursite.com/2018/05/08/bitcoin-and-blockchain/</id>
    <published>2018-05-08T15:34:47.000Z</published>
    <updated>2019-12-18T00:26:25.624Z</updated>
    
    <content type="html"><![CDATA[<h3 id="比特币及区块链的发展历史"><a href="#比特币及区块链的发展历史" class="headerlink" title="比特币及区块链的发展历史"></a>比特币及区块链的发展历史</h3><p>   大家接触和了解区块链，最早应该是从比特币开始的。确实，区块链确实也是起源于比特币，但是又不局限于货币圈。区块链可以在金融、保险、医疗、政府等领域被广泛使用。<br>    既然区块链起源于货币，那我们就从货币开始谈起。<br>    货币本质上是一种所有者与市场关于交换权的契约，根本上是所有者相互之间的约定。<br>    货币的发展从物物交换到现在的纸币、电子货币经历了漫长的过程。当初稀有的贝壳、金银等作为一般等价物，现在广泛使用纸币，纸币的制作成本也许只有几厘钱，但是却可以换取价值数百元或者更多的物品，原因是有国家的信用背书做约定，让人们相信几张制作成本为几厘钱的纸币，可以获取实际价值几百元的物品。近几年，电子货币已经走入人们的生活，每个人每笔钱的收入与支出仅仅是银行系统对于一个数字的加减，每笔交易也是银行在记账，并且，只有银行有记账权。</p><p>2008年全球经济危机中，因为美国政府拥有记账权，所以可以无限增发货币。一个叫中本聪觉得这样很不合理，于是他想出了一种新型支付体系系统：大家都有权来记账，货币不能超发，而且整个账本完全公开透明。这就是比特币产生的原因和动机。</p><p>中本聪在2008年全球金融危机爆发之后，在网上发表了一篇论文：《比特币：一种点对点式的电子现金系统》（Bitcoin: A Peer-to-Peer Electronic Cash System），文中描述了一种全新的、一种总量恒定、去中心化的电子现金系统的发行和流通问题，在这个系统中，信息公开透明，每一笔转账都会被全网记录。这篇论文就是所谓的比特币白皮书，这篇论文的问世，标志着比特币底层技术区块链的诞生。</p><h3 id="中本聪是谁？"><a href="#中本聪是谁？" class="headerlink" title="中本聪是谁？"></a>中本聪是谁？</h3><p>中本聪是比特币的开发者兼创始者，密码朋克邮件组成员之一（密码朋克可以算是一个极客组织，组织早起成员有非常多的IT精英，比如：维基百科创始人阿桑奇，BT下载的作者布拉姆科恩，万维网发明者蒂姆.伯纳斯.李，Facebook创始人之一肖恩帕克等）。但中本聪本人一直没有出现在公众视野。</p><p> 历史上也出现过很多位“中本聪”：</p><ul><li>2012年5月，计算机科学家泰德·尼尔森在YouTube上曝料化名中本聪是京都大学的数学教授望月新一，但是这个说法始终没有被认证。</li><li>2014年黑客黑进中本聪使用过的邮箱，然后找到了邮件的主人：多利安.中本；但是中本表示只是偶然发现了邮箱的用户名和密码，并不是中本聪本人</li><li>2016年5月，澳大利亚企业家克雷格·史蒂芬·赖特通过媒体宣布，自己就是比特币创始人中本聪，之后赖特宣布放弃证明自己是中本聪。</li></ul><p>到现在，中本聪到底是谁，大家还是不知道，只知道他坐拥百万枚比特币，还获得了诺贝尔经济学奖提名，被誉为世界上最神秘的人。</p><h4 id="区块链如何去中心化"><a href="#区块链如何去中心化" class="headerlink" title="区块链如何去中心化"></a>区块链如何去中心化</h4><p>什么是中心化？<br>中心化的特点是中心掌握分布节点的信息，分布节点之间不掌握其他节点的信息。如图：<br><img src="/img/block/center_1.png" alt="这里写图片描述"></p><p>目前的基本所有机构，都可以认为是一个“中心化”的机构，例如：我们使用的聊天工具——微信，那么中心节点就是腾讯公司，分布节点就相当于我们用户，我们的各种信息，都存在腾讯公司的数据库中，腾讯公司想要修改我们的信息，窃听我们的消息，是非常容易的，因为腾讯公司就是“中心”，我们微信上使用的一切，都要依赖于腾讯公司这个中心。依次类推，我们的银行系统（央行是中心），我们的货币系统（央行是中心），国家机构（中央政府是中心）。这就是“中心化”。</p><p>区块链是如何去中心化的呢？<br>区块链可以理解为是一个去中心化的分布式数据库。这个数据库不依赖任何机构和管理员，区块链的作用就是存储信息，数据库的数据由全网的节点共同维护，任何人都可以接入区块链网络，成为一个数据节点。如果向数据节点写入数据，这个节点会将写入的数据信息广播到相邻的节点，然后相邻的节点再广播到它们相邻的节点，最终会将信息广播给全网的所有节点，最后所有的节点会同步数据，保证一致性。</p><p><img src="/img/block/center_2.png" alt="这里写图片描述"></p><p>通俗的讲，就是将原来只有中心节点才有的数据，现在给它弄到全网中都有，不再依赖一个中心的公司或者机构，而是依赖全网络，哪怕修改了数据被篡改了一个或者多个节点，也没关系，区块链系统中实现了共识算法，简单来说，就是保证少数服从多数，最后以大多数节点的信息作为真正的信息，由于网络里有无数节点，目前没有哪个公司或者机构可以同时操控这些节点一起篡改数据。<br>假如用区块链制作的微博或者微信会怎样呢？所有发布的消息，将无法受其他人修改或者删除，也就是说，你发布了某某某XXXX的消息，微博公司将再也无法将其删除或修改。</p><h3 id="比特币的原理和运转机制"><a href="#比特币的原理和运转机制" class="headerlink" title="比特币的原理和运转机制"></a>比特币的原理和运转机制</h3><p>首先，对比特币有一个整体的了解，比特币实际上可以理解为一个文件，确切的说可以理解为一个账本。这个账本基本上长这个样：</p><p><img src="/img/block/bitcron_transaction.png" alt="这里写图片描述"></p><p>这个账本中“from” 和 “to” 代表的是不同的比特币地址，可以理解为比特币账户，在比特币世界中，是没有账户余额概念的，只有一笔笔的从一个账户转到另外账户的转账信息。每当发起一比交易的时候，比特币系统会先通过你的比特币地址查到你之前的所有交易记录，看你是否有足够的钱去支付这笔交易。</p><p>这个账本不同于私人账本或者是银行的账本，它是一个全网都有的账本，不归属于某个人，而且全网都一样，每个网络节点人手一份，而且都是相同的。</p><p>当某个人A想要向B转账5个比特币，A会在比特币网络中广播这个消息，收到消息的节点一边将账本的副本信息更新，一边将这个消息继续广播，直到全网所有节点都收到。</p><p>如何来判断这个A转账到B5个比特币的消息是正确的呢？<br>针对每一笔交易，除了有转账信息，还会有一个数字签名，这个数字签名是有比特币地址账号唯一的私钥将转账消息的数字摘要加密创建生成的，每个网络节点拿着A的公钥对数字签名进行解密验证，就可以判断消息的准确性。<br>如果把转账信息比作是一份合同，那这个数字签名，你就可以理解为是类似于合同上一个亲笔签名的东西，来确保消息的准确性。</p><p>比特币系统中，每时每刻都会有无数多的交易在发生，比特币系统将这些交易信息按组分配，每个组称之为一个<code>区块</code>(block)，然后将这些区块按照时间顺序用链表一个一个的串起来，称之为<code>区块链</code>(the block chain)。区块链中的每个区块会引用前一个区块，你可以反向追踪至第一个区块中的交易信息。未在区块链中的信息是“未交易”或者未排序的信息，任何节点都有能力将一组未经确定的交易打包进区块，然后将它打包进区块的事实广播出去。<br>比特币系统显然不会让所有节点都参打包区块，这样非乱死不可，比特币系统会以每十分钟为一个周期，出一道计算题，这个计算题超级难，让全网的节点参与计算，这道计算题其实就是对当前区块的全部内容做一个特殊计算，得到一个哈希值，全网的所有网络节点通过比拼计算速度，强行匹配出哈希的值，最先计算出哈希值的节点将取得打包区块的权利，生成一个新的块<code>block</code>并连入现有的区块链，然后广播至所有其他节点，其他节点开始同步更新；最先计算出结果的节点除了拥有“记账”的权利，还可以获得一定量的比特币，这其实就是比特币的发行过程。参与打包区块的过程其实就是“挖矿”，参与“挖矿”的节点就是“矿工”。<br>哪怕计算题超级难，也有可能同一时刻两个网络节点同时算出值来，假如真有两个节点同时算出值来，该怎么办呢？<br>系统会同时让两个节点都记账，这样一来，区块链就会产生“分叉”，如何解决分叉呢？等到下一个区块产生后，看下一个区块连接到了哪个“分叉点”，然后系统会选择最长的链条，并把分叉去除，原来打包的区块将消失，区块中的交易信息将会重新回到“未确定的交易”信息池中。过程如下图：</p><p>下图是一个区块链</p><p><img src="/img/block/block_chain.png" alt="这里写图片描述"></p><p>过十分钟后，有两个“矿工”同时解决了问题，并同时产生了两个区块，于是区块链分叉了。</p><p><img src="/img/block/fencha_block_chain.png" alt="这里写图片描述"></p><p>分叉就分叉吧，没关系，全网节点同步区块链信息，将分叉的区块链同步到了各自的节点上。接着又过了十分钟，系统又出了一个题，一个矿工解答出了问题，注意，根据系统设计，连续两次节点同时解出问题的概率已经很小了，几乎不能可能。哪怕真有，也没关系，继续进行，最终只保留链路最长的。</p><p><img src="/img/block/fencha_1_block_chain.png" alt="这里写图片描述"></p><p>这是我们将放弃最短的路线，留下最长的链路</p><p><img src="/img/block/fencha_block_chain_final.png" alt="这里写图片描述"></p><p>比特币是如何保持总量恒定的呢？</p><p>随着越来越多的计算机加入比特币网络，“矿工”的计算能力会越来越强，为了让“矿工”恒定在每十分钟打包一个区块发行一次比特币，中本聪设计矿工挖矿的难度每过2016个区块动态提高一次，使得调整后的难度保持在十分钟。<br>每个比特币可以细分到小数点后八位，也就是说可以拿着0.00000001个比特币来交易。<br>刚开始每打包一个区块发行50个比特币，每21万个区块后，打包一个区块发行的比特币减半，比特币系统规定每十分钟打包一个区块，这样打包21万个区块需要四年的时间，直至2140年，比特币将无法细分，比特币发行完毕，发行总量约为2100万枚。</p><h3 id="比特币和区块链的关系"><a href="#比特币和区块链的关系" class="headerlink" title="比特币和区块链的关系"></a>比特币和区块链的关系</h3><p>比特币是区块链技术的应用，区块链是比特币的底层实现。可以说比特币是区块链技术的第一款应用。<br>区块链技术有去中心化、匿名性、公开透明的特点，现在市场上利用区块链技术做了非常多的应用：各种电子货币、百度莱茨狗、360区块猫。但是被人熟知的不算多。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;比特币及区块链的发展历史&quot;&gt;&lt;a href=&quot;#比特币及区块链的发展历史&quot; class=&quot;headerlink&quot; title=&quot;比特币及区块链的发展历史&quot;&gt;&lt;/a&gt;比特币及区块链的发展历史&lt;/h3&gt;&lt;p&gt;   大家接触和了解区块链，最早应该是从比特币开始的。确实，
      
    
    </summary>
    
    
      <category term="Blockchain" scheme="http://yoursite.com/tags/Blockchain/"/>
    
  </entry>
  
  <entry>
    <title>HTTP 缓存详解</title>
    <link href="http://yoursite.com/2018/04/29/http-cache/"/>
    <id>http://yoursite.com/2018/04/29/http-cache/</id>
    <published>2018-04-28T18:09:58.000Z</published>
    <updated>2019-07-14T06:17:43.122Z</updated>
    
    <content type="html"><![CDATA[<h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><p>HTTP缓存主要用在对一些实时性要求不高的静态文件进行的缓存，往往都是存在浏览器端，防止这些“多余”的请求重复的访问服务器，对服务器造成压力，从而提高网站的性能。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>现有两端，浏览器C和服务器端S。</p><p><img src="/img/http_cache/http_cache_1.jpeg" alt="这里写图片描述"></p><p>浏览器向服务器发送请求，获取一个文件f</p><p><img src="/img/http_cache/http_cache_2.jpeg" alt="这里写图片描述"></p><p>服务器就把f给返回浏览器</p><p><img src="/img/http_cache/http_cache_3.jpeg" alt="这里写图片描述"></p><p>假如这个文件的内容变化不是那么快，一两周更新一次，浏览器每次请求服务器都返回相同的文件，岂不是对服务器资源的一种浪费？</p><p>如何解决呢？</p><p>浏览器把请求后拿到的文件存到本地，等下次请求的时候，看看本地是否有缓存文件，如果有，直接拿本地的文件，岂不是就不用请求服务器了？这其实就是http缓存的最最根本的原理。</p><p>C端浏览器端把请求来的文件缓存到如图下f的小方格内<br><img src="/img/http_cache/http_cache_4.jpeg" alt="这里写图片描述"></p><p>等到下次C端再次请求此文件时，就直接从浏览器缓存的文件中拿，而不再向S服务器端发起请求了</p><p><img src="/img/http_cache/http_cache_5.jpeg" alt="这里写图片描述"></p><p>以下浏览器截图中标红的部分，就是没有发起请求，直接从浏览器缓存中获取的数据</p><p><img src="/img/http_cache/http_cache_6.jpeg" alt="这里写图片描述"></p><h3 id="两种缓存方式"><a href="#两种缓存方式" class="headerlink" title="两种缓存方式"></a>两种缓存方式</h3><p>浏览器端有了缓存之后，不能一直有效吧，如果文件更新了，我们还继续使用浏览器缓存中的数据，虽说时效性不强，但长期使用旧文件也不算合理吧。</p><p>http协议提供了两种维度来让缓存失效：时间和文件的修改。</p><h3 id="利用时间来让缓存失效"><a href="#利用时间来让缓存失效" class="headerlink" title="利用时间来让缓存失效"></a>利用时间来让缓存失效</h3><p>时间维度很简单，就是设定一个缓存时间段，过了这个时间段，缓存就自动失效了，浏览器就会发起请求获取文件。这个设定时间的http字段就是<code>cache-control</code>字段。</p><p><code>cache-control</code> 可设置的字段值有：</p><ul><li>private ：客户端可以缓存</li><li>public ：客户端和代理服务器都可缓存，大部分情况可以认为public和private是一样的</li><li>max-age=xxx ：   缓存的内容将在 xxx 秒后失效 (时间就是在这儿设置的)</li><li>no-cache ：需要使用另外一种http缓存策略来验证缓存数据</li><li>no-store ：所有缓存策略都不会进行(这里指的是两种缓存策略都不会进行)</li></ul><p>cache-control 缓存原理</p><p>第一次访问请求，客户端C向服务端S发起一个文件请求，服务器返回文件并在<code>response</code>中加了响应头”Cache-Control:max-age=60”，这样一来，这个f文件只能在浏览器端存<br>60秒</p><p><img src="/img/http_cache/http_cache_7.jpeg" alt="这里写图片描述"></p><p>在这60秒钟，客户端请求服务器的f文件会直接从缓存中拿取</p><p><img src="/img/http_cache/http_cache_8.jpeg" alt="这里写图片描述"></p><p>60秒过后，缓存失效，浏览器再次请求文件需要重新向服务器发起请求。</p><p><img src="/img/http_cache/http_cache_9.jpeg" alt="这里写图片描述"></p><p>注意：假如说请求中包含“Cache-Control:max-age=0”或者“Cache-Control:no-store”无论响应中返回的”max-age”值是多少，都不会缓存到服务器。浏览器中对于地址栏中直接输入文件地址的请求做了优化处理，加上了“Cache-Control:max-age=0”，也就是说，如果这个css、js或者其他静态文件是通过你在浏览器上直接输入获得的，将会每时每刻都是获取最新的。</p><h3 id="通过查看文件的修改来让缓存失效"><a href="#通过查看文件的修改来让缓存失效" class="headerlink" title="通过查看文件的修改来让缓存失效"></a>通过查看文件的修改来让缓存失效</h3><p>这种维度比较的科学：浏览器先请求服务获得文件后，服务器会返回该文件的最后修改时间<code>Last-Modified</code>，作为文件的一个标识，下次浏览器请求的时候，会带着这个标识去请求(此时为<code>If-Modified-Since</code>)，然后服务器做校验，如果说时间标识<code>If-Modified-Since</code>等于服务器的文件修改时间，则说明没有修改，返回304状态码，浏览器从缓存中获取文件，但是如果浏览器保存的时间标识<code>If-Modified-Since</code>小于服务器端的文件修改时间，那么，说明文件发生了修改，浏览器就会重新获取新的文件。<br>（<code>If-Modified-Since</code>的时间如果大于服务器端文件的时间，会被认为是错误的请求）</p><p>如图，浏览器C向服务器发S起请求，服务器S返回文件的同时还会返回文件的最后修改时间<code>Last-Modified</code>作为文件时间标识，浏览器会将文件和文件时间标识都缓存起来。</p><p><img src="/img/http_cache/http_cache_10.jpeg" alt="这里写图片描述"></p><p>假如服务器端的文件f并没有被修改，服务器通过判断请求头带的时间标识<code>If-Modified-Since</code>得出结论后，都会返回状态码<code>304</code>告诉浏览器文件没有被修改，让浏览器使用缓存。</p><p><img src="/img/http_cache/http_cache_11.jpeg" alt="这里写图片描述"></p><p>假如服务器端的文件f修改了，那么，浏览器将重新获取文件，并缓存到浏览器中。</p><p><img src="/img/http_cache/http_cache_12.jpeg" alt="这里写图片描述"></p><p>虽然通过文件最后修改时间作为标识已经很完美了，但是，还是可能存在一个问题：就是有可能服务器端的文件修改后，又改回原来的样子，这样，虽然文件最后修改时间变了，但是，文件内容并没有改变。这样还是会有多余的请求到达服务器，该如何处理呢？<br>可以将文件内容作为一个唯一标识，例如可以对文件内容取MD5值作为字段(<code>etag</code>)也传给浏览器端，假如这个文件内容没变化，那么MD5值也不会改变。那么，处理流程就变成了这样：服务器端先判断文件修改时间是否发生了变化，如果发生了变化，那么再对比浏览器传来的<code>If-None-Match</code>即浏览器端保留的<code>E-tag</code>值，如果发生了变化，则证明文件修改了，需要浏览器重新下载文件，如果没有，则证明文件内容没变化，返回304状态码。</p><p>如图，浏览器C要访问服务器S的f文件，服务器S返回了文件最后修改时间<code>Last-Modified</code>和文件的内容标识<code>E-tag</code>，浏览器将这两个字段及其文件缓存了起来</p><p><img src="/img/http_cache/http_cache_13.jpeg" alt="这里写图片描述"></p><p>当文件最后修改时间没变，文件内容也没变的时候，返回304，让浏览器从缓存中拿取文件。</p><p><img src="/img/http_cache/http_cache_14.jpeg" alt="这里写图片描述"></p><p>当文件最后修改时间变了，文件内容没变的时候，返回304，让浏览器从缓存中拿取文件。</p><p><img src="/img/http_cache/http_cache_15.jpeg" alt="这里写图片描述"></p><p>当文件修改时间变了，文件内容也变了的时候，服务器会重新下发新的文件给浏览器。</p><p><img src="/img/http_cache/http_cache_16.jpeg" alt="这里写图片描述"></p><p>此维度让缓存失效牵扯的http字段有点多，我们最后整理一下：<br>文件最后修改时间字段：</p><ul><li>Response：<code>Last-Modified</code></li><li>Request：<code>If-Modified-Since</code></li></ul><p>文件内容标识字段：</p><ul><li>Response：<code>E-tag</code></li><li>Request：<code>If-None-Match</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;用途&quot;&gt;&lt;a href=&quot;#用途&quot; class=&quot;headerlink&quot; title=&quot;用途&quot;&gt;&lt;/a&gt;用途&lt;/h3&gt;&lt;p&gt;HTTP缓存主要用在对一些实时性要求不高的静态文件进行的缓存，往往都是存在浏览器端，防止这些“多余”的请求重复的访问服务器，对服务器造成压力
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>微博git使用中那些可圈可点的地方</title>
    <link href="http://yoursite.com/2018/04/05/WeiboSummary/"/>
    <id>http://yoursite.com/2018/04/05/WeiboSummary/</id>
    <published>2018-04-05T08:05:52.000Z</published>
    <updated>2019-07-14T06:17:43.115Z</updated>
    
    <content type="html"><![CDATA[<h3 id="构造干净的git历史线索"><a href="#构造干净的git历史线索" class="headerlink" title="构造干净的git历史线索"></a>构造干净的git历史线索</h3><h4 id="一般公司git的使用方式："><a href="#一般公司git的使用方式：" class="headerlink" title="一般公司git的使用方式："></a>一般公司git的使用方式：</h4><ul><li>一个master分支、一个dev分支，多个feature分支。</li><li>一个功能点或者功能模块一个feature分支，除了日常的正常的在feature分支的提交，还要注意从master中pull最新的代码到当前所在的feature分支上，以保证当前代码是在最新的代码基础之上开发的，当前feature分支开发结束后，合并到dev分支，等到下一版本的所有feature分支都提交到dev(有时候不用所有的，dev有几个feature分支测几个功能点),测试同学在dev分支上展开测试，测试过程中产生的bug，再拎出一个或者多个feature分支进行修改，直到没问题，然后将dev中的代码合并到master，上线，然后线上回归，接着改bug。</li></ul><p>合并分支所涉及的git指令有:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">git pull origin master //在feature分支上</span><br><span class="line">git checkout dev </span><br><span class="line">git pull</span><br><span class="line">git merge feature</span><br><span class="line">git push</span><br><span class="line"></span><br><span class="line">//最后上线</span><br><span class="line">git checkout master</span><br><span class="line">git pull</span><br><span class="line">git merge dev</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p>然后生成的git历史线<br><img src="/img/weibo/chuantaiyi.png" alt="img">  </p><p>呃。。。乱！</p><h4 id="微博工作中的使用："><a href="#微博工作中的使用：" class="headerlink" title="微博工作中的使用："></a>微博工作中的使用：</h4><ul><li>一个master分支，一个或者多个feature分支。</li><li>无dev分支，通常情况下远程分支只有一master分支，一两个feature分支（两个都是多的），从主干master中分出feature，开发过程中随时更新master上最新的代码，不用pull命令，而是rebase，测试环境直接用feature分支，测出的问题直接向feature分支中提，测的没问题之后，最后合并到master。</li><li>在把feature分支合并到master的时候，将多个commit合并成一个。</li><li>每个commit的内容都要写清楚</li></ul><p>合并分支所涉及的git指令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git checkout master </span><br><span class="line">git pull</span><br><span class="line">git checkout feature</span><br><span class="line">git rebase master</span><br><span class="line">git push —force</span><br></pre></td></tr></table></figure><p>将多个commit合并成一个的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git reset --soft xxxxxxxxxx</span><br><span class="line">git add xxxx</span><br><span class="line">git commit -m &quot;xxxx&quot;</span><br><span class="line">git push -f //一定要强制推送</span><br></pre></td></tr></table></figure><p><img src="/img/weibo/weibo_rebase.png" alt="img"></p><p>特别清晰有木有！</p><h4 id="git-merge和-git-rebase的区别"><a href="#git-merge和-git-rebase的区别" class="headerlink" title="git merge和 git rebase的区别"></a><code>git merge</code>和 <code>git rebase</code>的区别</h4><p>一句话概括：<code>git rebase</code>不产生“分叉”，就像在同一个分支上<code>commit</code>了一样，而merge会产生“分叉”</p><p>如下图：</p><p><img src="/img/weibo/merge_rebase.jpg" alt="img"></p><p><code>git pull</code> 等于<code>git fetch</code>加 <code>git merge</code>，每次从master更新代码的时候，如果使用<code>git pull origin master</code>相当于每次更新就<code>merge</code>了一下，因而会有很多“乱线” </p><h3 id="git-工具选择"><a href="#git-工具选择" class="headerlink" title="git 工具选择"></a>git 工具选择</h3><p>不要<code>SourceTree</code>、不要<code>Smartgit</code>，只用phpstrom自带的。</p><h4 id="查看异同并修改很方便"><a href="#查看异同并修改很方便" class="headerlink" title="查看异同并修改很方便"></a>查看异同并修改很方便</h4><p>准备提交代码:<br><img src="/img/weibo/shangchuan.png" alt="img"></p><p>查看修改了什么：<br><img src="/img/weibo/chakan.png" alt="img"></p><p>可以选择“查看不同”、“回滚整个文件”、“编辑当前代码”等操作,现在选择查看不同<br><img src="/img/weibo/chakan_diff.png" alt="img"></p><p>点击”x”可以直接回滚到原来</p><p><img src="/img/weibo/chakan1.png" alt="img"></p><p>填写commit、提交等操作</p><p><img src="/img/weibo/chakan1.png" alt="img"></p><p>不用来回切换工具，直接用IDE本身，会带来很多方便，IDE的可视化效果也比较好，可以清楚的看到改动的地方，并直接在IDE中修改，能够减少“忘记改动”带来的bug</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;构造干净的git历史线索&quot;&gt;&lt;a href=&quot;#构造干净的git历史线索&quot; class=&quot;headerlink&quot; title=&quot;构造干净的git历史线索&quot;&gt;&lt;/a&gt;构造干净的git历史线索&lt;/h3&gt;&lt;h4 id=&quot;一般公司git的使用方式：&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
</feed>
